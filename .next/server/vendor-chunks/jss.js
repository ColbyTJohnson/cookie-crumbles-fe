"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jss";
exports.ids = ["vendor-chunks/jss"];
exports.modules = {

/***/ "(ssr)/./node_modules/jss/dist/jss.esm.js":
/*!******************************************!*\
  !*** ./node_modules/jss/dist/jss.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuleList: () => (/* binding */ RuleList),\n/* harmony export */   SheetsManager: () => (/* binding */ SheetsManager),\n/* harmony export */   SheetsRegistry: () => (/* binding */ SheetsRegistry),\n/* harmony export */   create: () => (/* binding */ createJss),\n/* harmony export */   createGenerateId: () => (/* binding */ createGenerateId),\n/* harmony export */   createRule: () => (/* binding */ createRule),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getDynamicStyles: () => (/* binding */ getDynamicStyles),\n/* harmony export */   hasCSSTOMSupport: () => (/* binding */ hasCSSTOMSupport),\n/* harmony export */   sheets: () => (/* binding */ sheets),\n/* harmony export */   toCssValue: () => (/* binding */ toCssValue)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ \"(ssr)/./node_modules/is-in-browser/dist/module.js\");\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-warning */ \"(ssr)/./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\n\n\n\n\n\n\nvar plainObjectConstrurctor = {}.constructor;\nfunction cloneStyle(style) {\n    if (style == null || typeof style !== \"object\") return style;\n    if (Array.isArray(style)) return style.map(cloneStyle);\n    if (style.constructor !== plainObjectConstrurctor) return style;\n    var newStyle = {};\n    for(var name in style){\n        newStyle[name] = cloneStyle(style[name]);\n    }\n    return newStyle;\n}\n/**\n * Create a rule instance.\n */ function createRule(name, decl, options) {\n    if (name === void 0) {\n        name = \"unnamed\";\n    }\n    var jss = options.jss;\n    var declCopy = cloneStyle(decl);\n    var rule = jss.plugins.onCreateRule(name, declCopy, options);\n    if (rule) return rule; // It is an at-rule and it has no instance.\n    if (name[0] === \"@\") {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Unknown rule \" + name) : 0;\n    }\n    return null;\n}\nvar join = function join(value, by) {\n    var result = \"\";\n    for(var i = 0; i < value.length; i++){\n        // Remove !important from the value, it will be readded later.\n        if (value[i] === \"!important\") break;\n        if (result) result += by;\n        result += value[i];\n    }\n    return result;\n};\n/**\n * Converts JSS array value to a CSS string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */ var toCssValue = function toCssValue(value) {\n    if (!Array.isArray(value)) return value;\n    var cssValue = \"\"; // Support space separated values via `[['5px', '10px']]`.\n    if (Array.isArray(value[0])) {\n        for(var i = 0; i < value.length; i++){\n            if (value[i] === \"!important\") break;\n            if (cssValue) cssValue += \", \";\n            cssValue += join(value[i], \" \");\n        }\n    } else cssValue = join(value, \", \"); // Add !important, because it was ignored.\n    if (value[value.length - 1] === \"!important\") {\n        cssValue += \" !important\";\n    }\n    return cssValue;\n};\nfunction getWhitespaceSymbols(options) {\n    if (options && options.format === false) {\n        return {\n            linebreak: \"\",\n            space: \"\"\n        };\n    }\n    return {\n        linebreak: \"\\n\",\n        space: \" \"\n    };\n}\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */ function indentStr(str, indent) {\n    var result = \"\";\n    for(var index = 0; index < indent; index++){\n        result += \"  \";\n    }\n    return result + str;\n}\n/**\n * Converts a Rule to CSS string.\n */ function toCss(selector, style, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var result = \"\";\n    if (!style) return result;\n    var _options = options, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;\n    var fallbacks = style.fallbacks;\n    if (options.format === false) {\n        indent = -Infinity;\n    }\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak, space = _getWhitespaceSymbols.space;\n    if (selector) indent++; // Apply fallbacks first.\n    if (fallbacks) {\n        // Array syntax {fallbacks: [{prop: value}]}\n        if (Array.isArray(fallbacks)) {\n            for(var index = 0; index < fallbacks.length; index++){\n                var fallback = fallbacks[index];\n                for(var prop in fallback){\n                    var value = fallback[prop];\n                    if (value != null) {\n                        if (result) result += linebreak;\n                        result += indentStr(prop + \":\" + space + toCssValue(value) + \";\", indent);\n                    }\n                }\n            }\n        } else {\n            // Object syntax {fallbacks: {prop: value}}\n            for(var _prop in fallbacks){\n                var _value = fallbacks[_prop];\n                if (_value != null) {\n                    if (result) result += linebreak;\n                    result += indentStr(_prop + \":\" + space + toCssValue(_value) + \";\", indent);\n                }\n            }\n        }\n    }\n    for(var _prop2 in style){\n        var _value2 = style[_prop2];\n        if (_value2 != null && _prop2 !== \"fallbacks\") {\n            if (result) result += linebreak;\n            result += indentStr(_prop2 + \":\" + space + toCssValue(_value2) + \";\", indent);\n        }\n    } // Allow empty style in this case, because properties will be added dynamically.\n    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.\n    if (!selector) return result;\n    indent--;\n    if (result) result = \"\" + linebreak + result + linebreak;\n    return indentStr(\"\" + selector + space + \"{\" + result, indent) + indentStr(\"}\", indent);\n}\nvar escapeRegex = /([[\\].#*$><+~=|^:(),\"'`\\s])/g;\nvar nativeEscape = typeof CSS !== \"undefined\" && CSS.escape;\nvar escape = function(str) {\n    return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, \"\\\\$1\");\n};\nvar BaseStyleRule = /*#__PURE__*/ function() {\n    function BaseStyleRule(key, style, options) {\n        this.type = \"style\";\n        this.isProcessed = false;\n        var sheet = options.sheet, Renderer = options.Renderer;\n        this.key = key;\n        this.options = options;\n        this.style = style;\n        if (sheet) this.renderer = sheet.renderer;\n        else if (Renderer) this.renderer = new Renderer();\n    }\n    /**\n   * Get or set a style property.\n   */ var _proto = BaseStyleRule.prototype;\n    _proto.prop = function prop(name, value, options) {\n        // It's a getter.\n        if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.\n        var force = options ? options.force : false;\n        if (!force && this.style[name] === value) return this;\n        var newValue = value;\n        if (!options || options.process !== false) {\n            newValue = this.options.jss.plugins.onChangeValue(value, name, this);\n        }\n        var isEmpty = newValue == null || newValue === false;\n        var isDefined = name in this.style; // Value is empty and wasn't defined before.\n        if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.\n        var remove = isEmpty && isDefined;\n        if (remove) delete this.style[name];\n        else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.\n        if (this.renderable && this.renderer) {\n            if (remove) this.renderer.removeProperty(this.renderable, name);\n            else this.renderer.setProperty(this.renderable, name, newValue);\n            return this;\n        }\n        var sheet = this.options.sheet;\n        if (sheet && sheet.attached) {\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Rule is not linked. Missing sheet option \"link: true\".') : 0;\n        }\n        return this;\n    };\n    return BaseStyleRule;\n}();\nvar StyleRule = /*#__PURE__*/ function(_BaseStyleRule) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(StyleRule, _BaseStyleRule);\n    function StyleRule(key, style, options) {\n        var _this;\n        _this = _BaseStyleRule.call(this, key, style, options) || this;\n        var selector = options.selector, scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;\n        if (selector) {\n            _this.selectorText = selector;\n        } else if (scoped !== false) {\n            _this.id = generateId((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_this)), sheet);\n            _this.selectorText = \".\" + escape(_this.id);\n        }\n        return _this;\n    }\n    /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */ var _proto2 = StyleRule.prototype;\n    /**\n   * Apply rule to an element inline.\n   */ _proto2.applyTo = function applyTo(renderable) {\n        var renderer = this.renderer;\n        if (renderer) {\n            var json = this.toJSON();\n            for(var prop in json){\n                renderer.setProperty(renderable, prop, json[prop]);\n            }\n        }\n        return this;\n    } /**\n   * Returns JSON representation of the rule.\n   * Fallbacks are not supported.\n   * Useful for inline styles.\n   */ ;\n    _proto2.toJSON = function toJSON() {\n        var json = {};\n        for(var prop in this.style){\n            var value = this.style[prop];\n            if (typeof value !== \"object\") json[prop] = value;\n            else if (Array.isArray(value)) json[prop] = toCssValue(value);\n        }\n        return json;\n    } /**\n   * Generates a CSS string.\n   */ ;\n    _proto2.toString = function toString(options) {\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            allowEmpty: true\n        }) : options;\n        return toCss(this.selectorText, this.style, opts);\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(StyleRule, [\n        {\n            key: \"selector\",\n            set: function set(selector) {\n                if (selector === this.selectorText) return;\n                this.selectorText = selector;\n                var renderer = this.renderer, renderable = this.renderable;\n                if (!renderable || !renderer) return;\n                var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.\n                if (!hasChanged) {\n                    renderer.replaceRule(renderable, this);\n                }\n            },\n            get: function get() {\n                return this.selectorText;\n            }\n        }\n    ]);\n    return StyleRule;\n}(BaseStyleRule);\nvar pluginStyleRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        if (key[0] === \"@\" || options.parent && options.parent.type === \"keyframes\") {\n            return null;\n        }\n        return new StyleRule(key, style, options);\n    }\n};\nvar defaultToStringOptions = {\n    indent: 1,\n    children: true\n};\nvar atRegExp = /@([\\w-]+)/;\n/**\n * Conditional rule for @media, @supports\n */ var ConditionalRule = /*#__PURE__*/ function() {\n    function ConditionalRule(key, styles, options) {\n        this.type = \"conditional\";\n        this.isProcessed = false;\n        this.key = key;\n        var atMatch = key.match(atRegExp);\n        this.at = atMatch ? atMatch[1] : \"unknown\"; // Key might contain a unique suffix in case the `name` passed by user was duplicate.\n        this.query = options.name || \"@\" + this.at;\n        this.options = options;\n        this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            parent: this\n        }));\n        for(var name in styles){\n            this.rules.add(name, styles[name]);\n        }\n        this.rules.process();\n    }\n    /**\n   * Get a rule.\n   */ var _proto = ConditionalRule.prototype;\n    _proto.getRule = function getRule(name) {\n        return this.rules.get(name);\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.rules.indexOf(rule);\n    } /**\n   * Create and register rule, run plugins.\n   */ ;\n    _proto.addRule = function addRule(name, style, options) {\n        var rule = this.rules.add(name, style, options);\n        if (!rule) return null;\n        this.options.jss.plugins.onProcessRule(rule);\n        return rule;\n    } /**\n   * Replace rule, run plugins.\n   */ ;\n    _proto.replaceRule = function replaceRule(name, style, options) {\n        var newRule = this.rules.replace(name, style, options);\n        if (newRule) this.options.jss.plugins.onProcessRule(newRule);\n        return newRule;\n    } /**\n   * Generates a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        if (options === void 0) {\n            options = defaultToStringOptions;\n        }\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (options.indent == null) options.indent = defaultToStringOptions.indent;\n        if (options.children == null) options.children = defaultToStringOptions.children;\n        if (options.children === false) {\n            return this.query + \" {}\";\n        }\n        var children = this.rules.toString(options);\n        return children ? this.query + \" {\" + linebreak + children + linebreak + \"}\" : \"\";\n    };\n    return ConditionalRule;\n}();\nvar keyRegExp = /@container|@media|@supports\\s+/;\nvar pluginConditionalRule = {\n    onCreateRule: function onCreateRule(key, styles, options) {\n        return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;\n    }\n};\nvar defaultToStringOptions$1 = {\n    indent: 1,\n    children: true\n};\nvar nameRegExp = /@keyframes\\s+([\\w-]+)/;\n/**\n * Rule for @keyframes\n */ var KeyframesRule = /*#__PURE__*/ function() {\n    function KeyframesRule(key, frames, options) {\n        this.type = \"keyframes\";\n        this.at = \"@keyframes\";\n        this.isProcessed = false;\n        var nameMatch = key.match(nameRegExp);\n        if (nameMatch && nameMatch[1]) {\n            this.name = nameMatch[1];\n        } else {\n            this.name = \"noname\";\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Bad keyframes name \" + key) : 0;\n        }\n        this.key = this.type + \"-\" + this.name;\n        this.options = options;\n        var scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;\n        this.id = scoped === false ? this.name : escape(generateId(this, sheet));\n        this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            parent: this\n        }));\n        for(var name in frames){\n            this.rules.add(name, frames[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n                parent: this\n            }));\n        }\n        this.rules.process();\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = KeyframesRule.prototype;\n    _proto.toString = function toString(options) {\n        if (options === void 0) {\n            options = defaultToStringOptions$1;\n        }\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (options.indent == null) options.indent = defaultToStringOptions$1.indent;\n        if (options.children == null) options.children = defaultToStringOptions$1.children;\n        if (options.children === false) {\n            return this.at + \" \" + this.id + \" {}\";\n        }\n        var children = this.rules.toString(options);\n        if (children) children = \"\" + linebreak + children + linebreak;\n        return this.at + \" \" + this.id + \" {\" + children + \"}\";\n    };\n    return KeyframesRule;\n}();\nvar keyRegExp$1 = /@keyframes\\s+/;\nvar refRegExp = /\\$([\\w-]+)/g;\nvar findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {\n    if (typeof val === \"string\") {\n        return val.replace(refRegExp, function(match, name) {\n            if (name in keyframes) {\n                return keyframes[name];\n            }\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Referenced keyframes rule \"' + name + '\" is not defined.') : 0;\n            return match;\n        });\n    }\n    return val;\n};\n/**\n * Replace the reference for a animation name.\n */ var replaceRef = function replaceRef(style, prop, keyframes) {\n    var value = style[prop];\n    var refKeyframe = findReferencedKeyframe(value, keyframes);\n    if (refKeyframe !== value) {\n        style[prop] = refKeyframe;\n    }\n};\nvar pluginKeyframesRule = {\n    onCreateRule: function onCreateRule(key, frames, options) {\n        return typeof key === \"string\" && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;\n    },\n    // Animation name ref replacer.\n    onProcessStyle: function onProcessStyle(style, rule, sheet) {\n        if (rule.type !== \"style\" || !sheet) return style;\n        if (\"animation-name\" in style) replaceRef(style, \"animation-name\", sheet.keyframes);\n        if (\"animation\" in style) replaceRef(style, \"animation\", sheet.keyframes);\n        return style;\n    },\n    onChangeValue: function onChangeValue(val, prop, rule) {\n        var sheet = rule.options.sheet;\n        if (!sheet) {\n            return val;\n        }\n        switch(prop){\n            case \"animation\":\n                return findReferencedKeyframe(val, sheet.keyframes);\n            case \"animation-name\":\n                return findReferencedKeyframe(val, sheet.keyframes);\n            default:\n                return val;\n        }\n    }\n};\nvar KeyframeRule = /*#__PURE__*/ function(_BaseStyleRule) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(KeyframeRule, _BaseStyleRule);\n    function KeyframeRule() {\n        return _BaseStyleRule.apply(this, arguments) || this;\n    }\n    var _proto = KeyframeRule.prototype;\n    /**\n   * Generates a CSS string.\n   */ _proto.toString = function toString(options) {\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            allowEmpty: true\n        }) : options;\n        return toCss(this.key, this.style, opts);\n    };\n    return KeyframeRule;\n}(BaseStyleRule);\nvar pluginKeyframeRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        if (options.parent && options.parent.type === \"keyframes\") {\n            return new KeyframeRule(key, style, options);\n        }\n        return null;\n    }\n};\nvar FontFaceRule = /*#__PURE__*/ function() {\n    function FontFaceRule(key, style, options) {\n        this.type = \"font-face\";\n        this.at = \"@font-face\";\n        this.isProcessed = false;\n        this.key = key;\n        this.style = style;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = FontFaceRule.prototype;\n    _proto.toString = function toString(options) {\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (Array.isArray(this.style)) {\n            var str = \"\";\n            for(var index = 0; index < this.style.length; index++){\n                str += toCss(this.at, this.style[index]);\n                if (this.style[index + 1]) str += linebreak;\n            }\n            return str;\n        }\n        return toCss(this.at, this.style, options);\n    };\n    return FontFaceRule;\n}();\nvar keyRegExp$2 = /@font-face/;\nvar pluginFontFaceRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;\n    }\n};\nvar ViewportRule = /*#__PURE__*/ function() {\n    function ViewportRule(key, style, options) {\n        this.type = \"viewport\";\n        this.at = \"@viewport\";\n        this.isProcessed = false;\n        this.key = key;\n        this.style = style;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = ViewportRule.prototype;\n    _proto.toString = function toString(options) {\n        return toCss(this.key, this.style, options);\n    };\n    return ViewportRule;\n}();\nvar pluginViewportRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        return key === \"@viewport\" || key === \"@-ms-viewport\" ? new ViewportRule(key, style, options) : null;\n    }\n};\nvar SimpleRule = /*#__PURE__*/ function() {\n    function SimpleRule(key, value, options) {\n        this.type = \"simple\";\n        this.isProcessed = false;\n        this.key = key;\n        this.value = value;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ // eslint-disable-next-line no-unused-vars\n    var _proto = SimpleRule.prototype;\n    _proto.toString = function toString(options) {\n        if (Array.isArray(this.value)) {\n            var str = \"\";\n            for(var index = 0; index < this.value.length; index++){\n                str += this.key + \" \" + this.value[index] + \";\";\n                if (this.value[index + 1]) str += \"\\n\";\n            }\n            return str;\n        }\n        return this.key + \" \" + this.value + \";\";\n    };\n    return SimpleRule;\n}();\nvar keysMap = {\n    \"@charset\": true,\n    \"@import\": true,\n    \"@namespace\": true\n};\nvar pluginSimpleRule = {\n    onCreateRule: function onCreateRule(key, value, options) {\n        return key in keysMap ? new SimpleRule(key, value, options) : null;\n    }\n};\nvar plugins = [\n    pluginStyleRule,\n    pluginConditionalRule,\n    pluginKeyframesRule,\n    pluginKeyframeRule,\n    pluginFontFaceRule,\n    pluginViewportRule,\n    pluginSimpleRule\n];\nvar defaultUpdateOptions = {\n    process: true\n};\nvar forceUpdateOptions = {\n    force: true,\n    process: true\n};\nvar RuleList = /*#__PURE__*/ function() {\n    // Rules registry for access by .get() method.\n    // It contains the same rule registered by name and by selector.\n    // Original styles object.\n    // Used to ensure correct rules order.\n    function RuleList(options) {\n        this.map = {};\n        this.raw = {};\n        this.index = [];\n        this.counter = 0;\n        this.options = options;\n        this.classes = options.classes;\n        this.keyframes = options.keyframes;\n    }\n    /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */ var _proto = RuleList.prototype;\n    _proto.add = function add(name, decl, ruleOptions) {\n        var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss = _this$options.jss, Renderer = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;\n        var options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            classes: this.classes,\n            parent: parent,\n            sheet: sheet,\n            jss: jss,\n            Renderer: Renderer,\n            generateId: generateId,\n            scoped: scoped,\n            name: name,\n            keyframes: this.keyframes,\n            selector: undefined\n        }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but\n        // `sheet.addRule()` opens the door for any duplicate rule name. When this happens\n        // we need to make the key unique within this RuleList instance scope.\n        var key = name;\n        if (name in this.raw) {\n            key = name + \"-d\" + this.counter++;\n        } // We need to save the original decl before creating the rule\n        // because cache plugin needs to use it as a key to return a cached rule.\n        this.raw[key] = decl;\n        if (key in this.classes) {\n            // E.g. rules inside of @media container\n            options.selector = \".\" + escape(this.classes[key]);\n        }\n        var rule = createRule(key, decl, options);\n        if (!rule) return null;\n        this.register(rule);\n        var index = options.index === undefined ? this.index.length : options.index;\n        this.index.splice(index, 0, rule);\n        return rule;\n    } /**\n   * Replace rule.\n   * Create a new rule and remove old one instead of overwriting\n   * because we want to invoke onCreateRule hook to make plugins work.\n   */ ;\n    _proto.replace = function replace(name, decl, ruleOptions) {\n        var oldRule = this.get(name);\n        var oldIndex = this.index.indexOf(oldRule);\n        if (oldRule) {\n            this.remove(oldRule);\n        }\n        var options = ruleOptions;\n        if (oldIndex !== -1) options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, ruleOptions, {\n            index: oldIndex\n        });\n        return this.add(name, decl, options);\n    } /**\n   * Get a rule by name or selector.\n   */ ;\n    _proto.get = function get(nameOrSelector) {\n        return this.map[nameOrSelector];\n    } /**\n   * Delete a rule.\n   */ ;\n    _proto.remove = function remove(rule) {\n        this.unregister(rule);\n        delete this.raw[rule.key];\n        this.index.splice(this.index.indexOf(rule), 1);\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.index.indexOf(rule);\n    } /**\n   * Run `onProcessRule()` plugins on every rule.\n   */ ;\n    _proto.process = function process() {\n        var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop\n        // we end up with very hard-to-track-down side effects.\n        this.index.slice(0).forEach(plugins.onProcessRule, plugins);\n    } /**\n   * Register a rule in `.map`, `.classes` and `.keyframes` maps.\n   */ ;\n    _proto.register = function register(rule) {\n        this.map[rule.key] = rule;\n        if (rule instanceof StyleRule) {\n            this.map[rule.selector] = rule;\n            if (rule.id) this.classes[rule.key] = rule.id;\n        } else if (rule instanceof KeyframesRule && this.keyframes) {\n            this.keyframes[rule.name] = rule.id;\n        }\n    } /**\n   * Unregister a rule.\n   */ ;\n    _proto.unregister = function unregister(rule) {\n        delete this.map[rule.key];\n        if (rule instanceof StyleRule) {\n            delete this.map[rule.selector];\n            delete this.classes[rule.key];\n        } else if (rule instanceof KeyframesRule) {\n            delete this.keyframes[rule.name];\n        }\n    } /**\n   * Update the function values with a new data.\n   */ ;\n    _proto.update = function update() {\n        var name;\n        var data;\n        var options;\n        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === \"string\") {\n            name = arguments.length <= 0 ? undefined : arguments[0];\n            data = arguments.length <= 1 ? undefined : arguments[1];\n            options = arguments.length <= 2 ? undefined : arguments[2];\n        } else {\n            data = arguments.length <= 0 ? undefined : arguments[0];\n            options = arguments.length <= 1 ? undefined : arguments[1];\n            name = null;\n        }\n        if (name) {\n            this.updateOne(this.get(name), data, options);\n        } else {\n            for(var index = 0; index < this.index.length; index++){\n                this.updateOne(this.index[index], data, options);\n            }\n        }\n    } /**\n   * Execute plugins, update rule props.\n   */ ;\n    _proto.updateOne = function updateOne(rule, data, options) {\n        if (options === void 0) {\n            options = defaultUpdateOptions;\n        }\n        var _this$options2 = this.options, plugins = _this$options2.jss.plugins, sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.\n        if (rule.rules instanceof RuleList) {\n            rule.rules.update(data, options);\n            return;\n        }\n        var style = rule.style;\n        plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.\n        if (options.process && style && style !== rule.style) {\n            // We need to run the plugins in case new `style` relies on syntax plugins.\n            plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.\n            for(var prop in rule.style){\n                var nextValue = rule.style[prop];\n                var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n                if (nextValue !== prevValue) {\n                    rule.prop(prop, nextValue, forceUpdateOptions);\n                }\n            } // Remove props.\n            for(var _prop in style){\n                var _nextValue = rule.style[_prop];\n                var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n                if (_nextValue == null && _nextValue !== _prevValue) {\n                    rule.prop(_prop, null, forceUpdateOptions);\n                }\n            }\n        }\n    } /**\n   * Convert rules to a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        var str = \"\";\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        for(var index = 0; index < this.index.length; index++){\n            var rule = this.index[index];\n            var css = rule.toString(options); // No need to render an empty rule.\n            if (!css && !link) continue;\n            if (str) str += linebreak;\n            str += css;\n        }\n        return str;\n    };\n    return RuleList;\n}();\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(styles, options) {\n        this.attached = false;\n        this.deployed = false;\n        this.classes = {};\n        this.keyframes = {};\n        this.options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            sheet: this,\n            parent: this,\n            classes: this.classes,\n            keyframes: this.keyframes\n        });\n        if (options.Renderer) {\n            this.renderer = new options.Renderer(this);\n        }\n        this.rules = new RuleList(this.options);\n        for(var name in styles){\n            this.rules.add(name, styles[name]);\n        }\n        this.rules.process();\n    }\n    /**\n   * Attach renderable to the render tree.\n   */ var _proto = StyleSheet.prototype;\n    _proto.attach = function attach() {\n        if (this.attached) return this;\n        if (this.renderer) this.renderer.attach();\n        this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.\n        if (!this.deployed) this.deploy();\n        return this;\n    } /**\n   * Remove renderable from render tree.\n   */ ;\n    _proto.detach = function detach() {\n        if (!this.attached) return this;\n        if (this.renderer) this.renderer.detach();\n        this.attached = false;\n        return this;\n    } /**\n   * Add a rule to the current stylesheet.\n   * Will insert a rule also after the stylesheet has been rendered first time.\n   */ ;\n    _proto.addRule = function addRule(name, decl, options) {\n        var queue = this.queue; // Plugins can create rules.\n        // In order to preserve the right order, we need to queue all `.addRule` calls,\n        // which happen after the first `rules.add()` call.\n        if (this.attached && !queue) this.queue = [];\n        var rule = this.rules.add(name, decl, options);\n        if (!rule) return null;\n        this.options.jss.plugins.onProcessRule(rule);\n        if (this.attached) {\n            if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.\n            // It will be inserted all together when .attach is called.\n            if (queue) queue.push(rule);\n            else {\n                this.insertRule(rule);\n                if (this.queue) {\n                    this.queue.forEach(this.insertRule, this);\n                    this.queue = undefined;\n                }\n            }\n            return rule;\n        } // We can't add rules to a detached style node.\n        // We will redeploy the sheet once user will attach it.\n        this.deployed = false;\n        return rule;\n    } /**\n   * Replace a rule in the current stylesheet.\n   */ ;\n    _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {\n        var oldRule = this.rules.get(nameOrSelector);\n        if (!oldRule) return this.addRule(nameOrSelector, decl, options);\n        var newRule = this.rules.replace(nameOrSelector, decl, options);\n        if (newRule) {\n            this.options.jss.plugins.onProcessRule(newRule);\n        }\n        if (this.attached) {\n            if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.\n            // It will be inserted all together when .attach is called.\n            if (this.renderer) {\n                if (!newRule) {\n                    this.renderer.deleteRule(oldRule);\n                } else if (oldRule.renderable) {\n                    this.renderer.replaceRule(oldRule.renderable, newRule);\n                }\n            }\n            return newRule;\n        } // We can't replace rules to a detached style node.\n        // We will redeploy the sheet once user will attach it.\n        this.deployed = false;\n        return newRule;\n    } /**\n   * Insert rule into the StyleSheet\n   */ ;\n    _proto.insertRule = function insertRule(rule) {\n        if (this.renderer) {\n            this.renderer.insertRule(rule);\n        }\n    } /**\n   * Create and add rules.\n   * Will render also after Style Sheet was rendered the first time.\n   */ ;\n    _proto.addRules = function addRules(styles, options) {\n        var added = [];\n        for(var name in styles){\n            var rule = this.addRule(name, styles[name], options);\n            if (rule) added.push(rule);\n        }\n        return added;\n    } /**\n   * Get a rule by name or selector.\n   */ ;\n    _proto.getRule = function getRule(nameOrSelector) {\n        return this.rules.get(nameOrSelector);\n    } /**\n   * Delete a rule by name.\n   * Returns `true`: if rule has been deleted from the DOM.\n   */ ;\n    _proto.deleteRule = function deleteRule(name) {\n        var rule = typeof name === \"object\" ? name : this.rules.get(name);\n        if (!rule || // Style sheet was created without link: true and attached, in this case we\n        // won't be able to remove the CSS rule from the DOM.\n        this.attached && !rule.renderable) {\n            return false;\n        }\n        this.rules.remove(rule);\n        if (this.attached && rule.renderable && this.renderer) {\n            return this.renderer.deleteRule(rule.renderable);\n        }\n        return true;\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.rules.indexOf(rule);\n    } /**\n   * Deploy pure CSS string to a renderable.\n   */ ;\n    _proto.deploy = function deploy() {\n        if (this.renderer) this.renderer.deploy();\n        this.deployed = true;\n        return this;\n    } /**\n   * Update the function values with a new data.\n   */ ;\n    _proto.update = function update() {\n        var _this$rules;\n        (_this$rules = this.rules).update.apply(_this$rules, arguments);\n        return this;\n    } /**\n   * Updates a single rule.\n   */ ;\n    _proto.updateOne = function updateOne(rule, data, options) {\n        this.rules.updateOne(rule, data, options);\n        return this;\n    } /**\n   * Convert rules to a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        return this.rules.toString(options);\n    };\n    return StyleSheet;\n}();\nvar PluginsRegistry = /*#__PURE__*/ function() {\n    function PluginsRegistry() {\n        this.plugins = {\n            internal: [],\n            external: []\n        };\n        this.registry = {};\n    }\n    var _proto = PluginsRegistry.prototype;\n    /**\n   * Call `onCreateRule` hooks and return an object if returned by a hook.\n   */ _proto.onCreateRule = function onCreateRule(name, decl, options) {\n        for(var i = 0; i < this.registry.onCreateRule.length; i++){\n            var rule = this.registry.onCreateRule[i](name, decl, options);\n            if (rule) return rule;\n        }\n        return null;\n    } /**\n   * Call `onProcessRule` hooks.\n   */ ;\n    _proto.onProcessRule = function onProcessRule(rule) {\n        if (rule.isProcessed) return;\n        var sheet = rule.options.sheet;\n        for(var i = 0; i < this.registry.onProcessRule.length; i++){\n            this.registry.onProcessRule[i](rule, sheet);\n        }\n        if (rule.style) this.onProcessStyle(rule.style, rule, sheet);\n        rule.isProcessed = true;\n    } /**\n   * Call `onProcessStyle` hooks.\n   */ ;\n    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {\n        for(var i = 0; i < this.registry.onProcessStyle.length; i++){\n            rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);\n        }\n    } /**\n   * Call `onProcessSheet` hooks.\n   */ ;\n    _proto.onProcessSheet = function onProcessSheet(sheet) {\n        for(var i = 0; i < this.registry.onProcessSheet.length; i++){\n            this.registry.onProcessSheet[i](sheet);\n        }\n    } /**\n   * Call `onUpdate` hooks.\n   */ ;\n    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {\n        for(var i = 0; i < this.registry.onUpdate.length; i++){\n            this.registry.onUpdate[i](data, rule, sheet, options);\n        }\n    } /**\n   * Call `onChangeValue` hooks.\n   */ ;\n    _proto.onChangeValue = function onChangeValue(value, prop, rule) {\n        var processedValue = value;\n        for(var i = 0; i < this.registry.onChangeValue.length; i++){\n            processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);\n        }\n        return processedValue;\n    } /**\n   * Register a plugin.\n   */ ;\n    _proto.use = function use(newPlugin, options) {\n        if (options === void 0) {\n            options = {\n                queue: \"external\"\n            };\n        }\n        var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.\n        if (plugins.indexOf(newPlugin) !== -1) {\n            return;\n        }\n        plugins.push(newPlugin);\n        this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry, plugin) {\n            for(var name in plugin){\n                if (name in registry) {\n                    registry[name].push(plugin[name]);\n                } else {\n                     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Unknown hook \"' + name + '\".') : 0;\n                }\n            }\n            return registry;\n        }, {\n            onCreateRule: [],\n            onProcessRule: [],\n            onProcessStyle: [],\n            onProcessSheet: [],\n            onChangeValue: [],\n            onUpdate: []\n        });\n    };\n    return PluginsRegistry;\n}();\n/**\n * Sheets registry to access all instances in one place.\n */ var SheetsRegistry = /*#__PURE__*/ function() {\n    function SheetsRegistry() {\n        this.registry = [];\n    }\n    var _proto = SheetsRegistry.prototype;\n    /**\n   * Register a Style Sheet.\n   */ _proto.add = function add(sheet) {\n        var registry = this.registry;\n        var index = sheet.options.index;\n        if (registry.indexOf(sheet) !== -1) return;\n        if (registry.length === 0 || index >= this.index) {\n            registry.push(sheet);\n            return;\n        } // Find a position.\n        for(var i = 0; i < registry.length; i++){\n            if (registry[i].options.index > index) {\n                registry.splice(i, 0, sheet);\n                return;\n            }\n        }\n    } /**\n   * Reset the registry.\n   */ ;\n    _proto.reset = function reset() {\n        this.registry = [];\n    } /**\n   * Remove a Style Sheet.\n   */ ;\n    _proto.remove = function remove(sheet) {\n        var index = this.registry.indexOf(sheet);\n        this.registry.splice(index, 1);\n    } /**\n   * Convert all attached sheets to a CSS string.\n   */ ;\n    _proto.toString = function toString(_temp) {\n        var _ref = _temp === void 0 ? {} : _temp, attached = _ref.attached, options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_ref, [\n            \"attached\"\n        ]);\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        var css = \"\";\n        for(var i = 0; i < this.registry.length; i++){\n            var sheet = this.registry[i];\n            if (attached != null && sheet.attached !== attached) {\n                continue;\n            }\n            if (css) css += linebreak;\n            css += sheet.toString(options);\n        }\n        return css;\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(SheetsRegistry, [\n        {\n            key: \"index\",\n            /**\n     * Current highest index number.\n     */ get: function get() {\n                return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;\n            }\n        }\n    ]);\n    return SheetsRegistry;\n}();\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */ var sheets = new SheetsRegistry();\n/* eslint-disable */ /**\n * Now that `globalThis` is available on most platforms\n * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)\n * we check for `globalThis` first. `globalThis` is necessary for jss\n * to run in Agoric's secure version of JavaScript (SES). Under SES,\n * `globalThis` exists, but `window`, `self`, and `Function('return\n * this')()` are all undefined for security reasons.\n *\n * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n */ var globalThis$1 = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof self !== \"undefined\" && self.Math === Math ? self : Function(\"return this\")();\nvar ns = \"2f1acc6c3a606b082e5eef5e54414ffb\";\nif (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify\n// the current version with just one short number and use it for classes generation\n// we use a counter. Also it is more accurate, because user can manually reevaluate\n// the module.\nvar moduleId = globalThis$1[ns]++;\nvar maxRules = 1e10;\n/**\n * Returns a function which generates unique class names based on counters.\n * When new generator function is created, rule counter is reseted.\n * We need to reset the rule counter for SSR for each request.\n */ var createGenerateId = function createGenerateId(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var ruleCounter = 0;\n    var generateId = function generateId(rule, sheet) {\n        ruleCounter += 1;\n        if (ruleCounter > maxRules) {\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] You might have a memory leak. Rule counter is at \" + ruleCounter + \".\") : 0;\n        }\n        var jssId = \"\";\n        var prefix = \"\";\n        if (sheet) {\n            if (sheet.options.classNamePrefix) {\n                prefix = sheet.options.classNamePrefix;\n            }\n            if (sheet.options.jss.id != null) {\n                jssId = String(sheet.options.jss.id);\n            }\n        }\n        if (options.minify) {\n            // Using \"c\" because a number can't be the first char in a class name.\n            return \"\" + (prefix || \"c\") + moduleId + jssId + ruleCounter;\n        }\n        return prefix + rule.key + \"-\" + moduleId + (jssId ? \"-\" + jssId : \"\") + \"-\" + ruleCounter;\n    };\n    return generateId;\n};\n/**\n * Cache the value from the first time a function is called.\n */ var memoize = function memoize(fn) {\n    var value;\n    return function() {\n        if (!value) value = fn();\n        return value;\n    };\n};\n/**\n * Get a style property value.\n */ var getPropertyValue = function getPropertyValue(cssRule, prop) {\n    try {\n        // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            return cssRule.attributeStyleMap.get(prop);\n        }\n        return cssRule.style.getPropertyValue(prop);\n    } catch (err) {\n        // IE may throw if property is unknown.\n        return \"\";\n    }\n};\n/**\n * Set a style property.\n */ var setProperty = function setProperty(cssRule, prop, value) {\n    try {\n        var cssValue = value;\n        if (Array.isArray(value)) {\n            cssValue = toCssValue(value);\n        } // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            cssRule.attributeStyleMap.set(prop, cssValue);\n        } else {\n            var indexOfImportantFlag = cssValue ? cssValue.indexOf(\"!important\") : -1;\n            var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;\n            cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? \"important\" : \"\");\n        }\n    } catch (err) {\n        // IE may throw if property is unknown.\n        return false;\n    }\n    return true;\n};\n/**\n * Remove a style property.\n */ var removeProperty = function removeProperty(cssRule, prop) {\n    try {\n        // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            cssRule.attributeStyleMap.delete(prop);\n        } else {\n            cssRule.style.removeProperty(prop);\n        }\n    } catch (err) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] DOMException \"' + err.message + '\" was thrown. Tried to remove property \"' + prop + '\".') : 0;\n    }\n};\n/**\n * Set the selector.\n */ var setSelector = function setSelector(cssRule, selectorText) {\n    cssRule.selectorText = selectorText; // Return false if setter was not successful.\n    // Currently works in chrome only.\n    return cssRule.selectorText === selectorText;\n};\n/**\n * Gets the `head` element upon the first call and caches it.\n * We assume it can't be null.\n */ var getHead = memoize(function() {\n    return document.querySelector(\"head\");\n});\n/**\n * Find attached sheet with an index higher than the passed one.\n */ function findHigherSheet(registry, options) {\n    for(var i = 0; i < registry.length; i++){\n        var sheet = registry[i];\n        if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {\n            return sheet;\n        }\n    }\n    return null;\n}\n/**\n * Find attached sheet with the highest index.\n */ function findHighestSheet(registry, options) {\n    for(var i = registry.length - 1; i >= 0; i--){\n        var sheet = registry[i];\n        if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {\n            return sheet;\n        }\n    }\n    return null;\n}\n/**\n * Find a comment with \"jss\" inside.\n */ function findCommentNode(text) {\n    var head = getHead();\n    for(var i = 0; i < head.childNodes.length; i++){\n        var node = head.childNodes[i];\n        if (node.nodeType === 8 && node.nodeValue.trim() === text) {\n            return node;\n        }\n    }\n    return null;\n}\n/**\n * Find a node before which we can insert the sheet.\n */ function findPrevNode(options) {\n    var registry = sheets.registry;\n    if (registry.length > 0) {\n        // Try to insert before the next higher sheet.\n        var sheet = findHigherSheet(registry, options);\n        if (sheet && sheet.renderer) {\n            return {\n                parent: sheet.renderer.element.parentNode,\n                node: sheet.renderer.element\n            };\n        } // Otherwise insert after the last attached.\n        sheet = findHighestSheet(registry, options);\n        if (sheet && sheet.renderer) {\n            return {\n                parent: sheet.renderer.element.parentNode,\n                node: sheet.renderer.element.nextSibling\n            };\n        }\n    } // Try to find a comment placeholder if registry is empty.\n    var insertionPoint = options.insertionPoint;\n    if (insertionPoint && typeof insertionPoint === \"string\") {\n        var comment = findCommentNode(insertionPoint);\n        if (comment) {\n            return {\n                parent: comment.parentNode,\n                node: comment.nextSibling\n            };\n        } // If user specifies an insertion point and it can't be found in the document -\n        // bad specificity issues may appear.\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Insertion point \"' + insertionPoint + '\" not found.') : 0;\n    }\n    return false;\n}\n/**\n * Insert style element into the DOM.\n */ function insertStyle(style, options) {\n    var insertionPoint = options.insertionPoint;\n    var nextNode = findPrevNode(options);\n    if (nextNode !== false && nextNode.parent) {\n        nextNode.parent.insertBefore(style, nextNode.node);\n        return;\n    } // Works with iframes and any node types.\n    if (insertionPoint && typeof insertionPoint.nodeType === \"number\") {\n        var insertionPointElement = insertionPoint;\n        var parentNode = insertionPointElement.parentNode;\n        if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);\n        else  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Insertion point is not in the DOM.\") : 0;\n        return;\n    }\n    getHead().appendChild(style);\n}\n/**\n * Read jss nonce setting from the page if the user has set it.\n */ var getNonce = memoize(function() {\n    var node = document.querySelector('meta[property=\"csp-nonce\"]');\n    return node ? node.getAttribute(\"content\") : null;\n});\nvar _insertRule = function insertRule(container, rule, index) {\n    try {\n        if (\"insertRule\" in container) {\n            container.insertRule(rule, index);\n        } else if (\"appendRule\" in container) {\n            container.appendRule(rule);\n        }\n    } catch (err) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] \" + err.message) : 0;\n        return false;\n    }\n    return container.cssRules[index];\n};\nvar getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {\n    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong\n    if (index === undefined || index > maxIndex) {\n        // eslint-disable-next-line no-param-reassign\n        return maxIndex;\n    }\n    return index;\n};\nvar createStyle = function createStyle() {\n    var el = document.createElement(\"style\"); // Without it, IE will have a broken source order specificity if we\n    // insert rules after we insert the style tag.\n    // It seems to kick-off the source order specificity algorithm.\n    el.textContent = \"\\n\";\n    return el;\n};\nvar DomRenderer = /*#__PURE__*/ function() {\n    // Will be empty if link: true option is not set, because\n    // it is only for use together with insertRule API.\n    function DomRenderer(sheet) {\n        this.getPropertyValue = getPropertyValue;\n        this.setProperty = setProperty;\n        this.removeProperty = removeProperty;\n        this.setSelector = setSelector;\n        this.hasInsertedRules = false;\n        this.cssRules = [];\n        // There is no sheet when the renderer is used from a standalone StyleRule.\n        if (sheet) sheets.add(sheet);\n        this.sheet = sheet;\n        var _ref = this.sheet ? this.sheet.options : {}, media = _ref.media, meta = _ref.meta, element = _ref.element;\n        this.element = element || createStyle();\n        this.element.setAttribute(\"data-jss\", \"\");\n        if (media) this.element.setAttribute(\"media\", media);\n        if (meta) this.element.setAttribute(\"data-meta\", meta);\n        var nonce = getNonce();\n        if (nonce) this.element.setAttribute(\"nonce\", nonce);\n    }\n    /**\n   * Insert style element into render tree.\n   */ var _proto = DomRenderer.prototype;\n    _proto.attach = function attach() {\n        // In the case the element node is external and it is already in the DOM.\n        if (this.element.parentNode || !this.sheet) return;\n        insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`\n        // most browsers create a new CSSStyleSheet, except of all IEs.\n        var deployed = Boolean(this.sheet && this.sheet.deployed);\n        if (this.hasInsertedRules && deployed) {\n            this.hasInsertedRules = false;\n            this.deploy();\n        }\n    } /**\n   * Remove style element from render tree.\n   */ ;\n    _proto.detach = function detach() {\n        if (!this.sheet) return;\n        var parentNode = this.element.parentNode;\n        if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.\n        // Though IE will keep them and we need a consistent behavior.\n        if (this.sheet.options.link) {\n            this.cssRules = [];\n            this.element.textContent = \"\\n\";\n        }\n    } /**\n   * Inject CSS string into element.\n   */ ;\n    _proto.deploy = function deploy() {\n        var sheet = this.sheet;\n        if (!sheet) return;\n        if (sheet.options.link) {\n            this.insertRules(sheet.rules);\n            return;\n        }\n        this.element.textContent = \"\\n\" + sheet.toString() + \"\\n\";\n    } /**\n   * Insert RuleList into an element.\n   */ ;\n    _proto.insertRules = function insertRules(rules, nativeParent) {\n        for(var i = 0; i < rules.index.length; i++){\n            this.insertRule(rules.index[i], i, nativeParent);\n        }\n    } /**\n   * Insert a rule into element.\n   */ ;\n    _proto.insertRule = function insertRule(rule, index, nativeParent) {\n        if (nativeParent === void 0) {\n            nativeParent = this.element.sheet;\n        }\n        if (rule.rules) {\n            var parent = rule;\n            var latestNativeParent = nativeParent;\n            if (rule.type === \"conditional\" || rule.type === \"keyframes\") {\n                var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.\n                latestNativeParent = _insertRule(nativeParent, parent.toString({\n                    children: false\n                }), _insertionIndex);\n                if (latestNativeParent === false) {\n                    return false;\n                }\n                this.refCssRule(rule, _insertionIndex, latestNativeParent);\n            }\n            this.insertRules(parent.rules, latestNativeParent);\n            return latestNativeParent;\n        }\n        var ruleStr = rule.toString();\n        if (!ruleStr) return false;\n        var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);\n        var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);\n        if (nativeRule === false) {\n            return false;\n        }\n        this.hasInsertedRules = true;\n        this.refCssRule(rule, insertionIndex, nativeRule);\n        return nativeRule;\n    };\n    _proto.refCssRule = function refCssRule(rule, index, cssRule) {\n        rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules\n        // like rules inside media queries or keyframes\n        if (rule.options.parent instanceof StyleSheet) {\n            this.cssRules.splice(index, 0, cssRule);\n        }\n    } /**\n   * Delete a rule.\n   */ ;\n    _proto.deleteRule = function deleteRule(cssRule) {\n        var sheet = this.element.sheet;\n        var index = this.indexOf(cssRule);\n        if (index === -1) return false;\n        sheet.deleteRule(index);\n        this.cssRules.splice(index, 1);\n        return true;\n    } /**\n   * Get index of a CSS Rule.\n   */ ;\n    _proto.indexOf = function indexOf(cssRule) {\n        return this.cssRules.indexOf(cssRule);\n    } /**\n   * Generate a new CSS rule and replace the existing one.\n   */ ;\n    _proto.replaceRule = function replaceRule(cssRule, rule) {\n        var index = this.indexOf(cssRule);\n        if (index === -1) return false;\n        this.element.sheet.deleteRule(index);\n        this.cssRules.splice(index, 1);\n        return this.insertRule(rule, index);\n    } /**\n   * Get all rules elements.\n   */ ;\n    _proto.getRules = function getRules() {\n        return this.element.sheet.cssRules;\n    };\n    return DomRenderer;\n}();\nvar instanceCounter = 0;\nvar Jss = /*#__PURE__*/ function() {\n    function Jss(options) {\n        this.id = instanceCounter++;\n        this.version = \"10.10.0\";\n        this.plugins = new PluginsRegistry();\n        this.options = {\n            id: {\n                minify: false\n            },\n            createGenerateId: createGenerateId,\n            Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? DomRenderer : null,\n            plugins: []\n        };\n        this.generateId = createGenerateId({\n            minify: false\n        });\n        for(var i = 0; i < plugins.length; i++){\n            this.plugins.use(plugins[i], {\n                queue: \"internal\"\n            });\n        }\n        this.setup(options);\n    }\n    /**\n   * Prepares various options, applies plugins.\n   * Should not be used twice on the same instance, because there is no plugins\n   * deduplication logic.\n   */ var _proto = Jss.prototype;\n    _proto.setup = function setup(options) {\n        if (options === void 0) {\n            options = {};\n        }\n        if (options.createGenerateId) {\n            this.options.createGenerateId = options.createGenerateId;\n        }\n        if (options.id) {\n            this.options.id = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, this.options.id, options.id);\n        }\n        if (options.createGenerateId || options.id) {\n            this.generateId = this.options.createGenerateId(this.options.id);\n        }\n        if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;\n        if (\"Renderer\" in options) {\n            this.options.Renderer = options.Renderer;\n        } // eslint-disable-next-line prefer-spread\n        if (options.plugins) this.use.apply(this, options.plugins);\n        return this;\n    } /**\n   * Create a Style Sheet.\n   */ ;\n    _proto.createStyleSheet = function createStyleSheet(styles, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, index = _options.index;\n        if (typeof index !== \"number\") {\n            index = sheets.index === 0 ? 0 : sheets.index + 1;\n        }\n        var sheet = new StyleSheet(styles, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            jss: this,\n            generateId: options.generateId || this.generateId,\n            insertionPoint: this.options.insertionPoint,\n            Renderer: this.options.Renderer,\n            index: index\n        }));\n        this.plugins.onProcessSheet(sheet);\n        return sheet;\n    } /**\n   * Detach the Style Sheet and remove it from the registry.\n   */ ;\n    _proto.removeStyleSheet = function removeStyleSheet(sheet) {\n        sheet.detach();\n        sheets.remove(sheet);\n        return this;\n    } /**\n   * Create a rule without a Style Sheet.\n   * [Deprecated] will be removed in the next major version.\n   */ ;\n    _proto.createRule = function createRule$1(name, style, options) {\n        if (style === void 0) {\n            style = {};\n        }\n        if (options === void 0) {\n            options = {};\n        }\n        // Enable rule without name for inline styles.\n        if (typeof name === \"object\") {\n            return this.createRule(undefined, name, style);\n        }\n        var ruleOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            name: name,\n            jss: this,\n            Renderer: this.options.Renderer\n        });\n        if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;\n        if (!ruleOptions.classes) ruleOptions.classes = {};\n        if (!ruleOptions.keyframes) ruleOptions.keyframes = {};\n        var rule = createRule(name, style, ruleOptions);\n        if (rule) this.plugins.onProcessRule(rule);\n        return rule;\n    } /**\n   * Register plugin. Passed function will be invoked with a rule instance.\n   */ ;\n    _proto.use = function use() {\n        var _this = this;\n        for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n            plugins[_key] = arguments[_key];\n        }\n        plugins.forEach(function(plugin) {\n            _this.plugins.use(plugin);\n        });\n        return this;\n    };\n    return Jss;\n}();\nvar createJss = function createJss(options) {\n    return new Jss(options);\n};\n/**\n * SheetsManager is like a WeakMap which is designed to count StyleSheet\n * instances and attach/detach automatically.\n * Used in react-jss.\n */ var SheetsManager = /*#__PURE__*/ function() {\n    function SheetsManager() {\n        this.length = 0;\n        this.sheets = new WeakMap();\n    }\n    var _proto = SheetsManager.prototype;\n    _proto.get = function get(key) {\n        var entry = this.sheets.get(key);\n        return entry && entry.sheet;\n    };\n    _proto.add = function add(key, sheet) {\n        if (this.sheets.has(key)) return;\n        this.length++;\n        this.sheets.set(key, {\n            sheet: sheet,\n            refs: 0\n        });\n    };\n    _proto.manage = function manage(key) {\n        var entry = this.sheets.get(key);\n        if (entry) {\n            if (entry.refs === 0) {\n                entry.sheet.attach();\n            }\n            entry.refs++;\n            return entry.sheet;\n        }\n        (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] SheetsManager: can't find sheet to manage\");\n        return undefined;\n    };\n    _proto.unmanage = function unmanage(key) {\n        var entry = this.sheets.get(key);\n        if (entry) {\n            if (entry.refs > 0) {\n                entry.refs--;\n                if (entry.refs === 0) entry.sheet.detach();\n            }\n        } else {\n            (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"SheetsManager: can't find sheet to unmanage\");\n        }\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(SheetsManager, [\n        {\n            key: \"size\",\n            get: function get() {\n                return this.length;\n            }\n        }\n    ]);\n    return SheetsManager;\n}();\n/**\n* Export a constant indicating if this browser has CSSTOM support.\n* https://developers.google.com/web/updates/2018/03/cssom\n*/ var hasCSSTOMSupport = typeof CSS === \"object\" && CSS != null && \"number\" in CSS;\n/**\n * Extracts a styles object with only props that contain function values.\n */ function getDynamicStyles(styles) {\n    var to = null;\n    for(var key in styles){\n        var value = styles[key];\n        var type = typeof value;\n        if (type === \"function\") {\n            if (!to) to = {};\n            to[key] = value;\n        } else if (type === \"object\" && value !== null && !Array.isArray(value)) {\n            var extracted = getDynamicStyles(value);\n            if (extracted) {\n                if (!to) to = {};\n                to[key] = extracted;\n            }\n        }\n    }\n    return to;\n}\n/**\n * A better abstraction over CSS.\n *\n * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present\n * @website https://github.com/cssinjs/jss\n * @license MIT\n */ var index = createJss();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDbEI7QUFDTDtBQUMrQjtBQUNJO0FBQ2dCO0FBQ2M7QUFFcEcsSUFBSU8sMEJBQTBCLENBQUMsRUFBRUMsV0FBVztBQUM1QyxTQUFTQyxXQUFXQyxLQUFLO0lBQ3ZCLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFVBQVUsT0FBT0E7SUFDdkQsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRLE9BQU9BLE1BQU1HLEdBQUcsQ0FBQ0o7SUFDM0MsSUFBSUMsTUFBTUYsV0FBVyxLQUFLRCx5QkFBeUIsT0FBT0c7SUFDMUQsSUFBSUksV0FBVyxDQUFDO0lBRWhCLElBQUssSUFBSUMsUUFBUUwsTUFBTztRQUN0QkksUUFBUSxDQUFDQyxLQUFLLEdBQUdOLFdBQVdDLEtBQUssQ0FBQ0ssS0FBSztJQUN6QztJQUVBLE9BQU9EO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELFNBQVNFLFdBQVdELElBQUksRUFBRUUsSUFBSSxFQUFFQyxPQUFPO0lBQ3JDLElBQUlILFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJSSxNQUFNRCxRQUFRQyxHQUFHO0lBQ3JCLElBQUlDLFdBQVdYLFdBQVdRO0lBQzFCLElBQUlJLE9BQU9GLElBQUlHLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDUixNQUFNSyxVQUFVRjtJQUNwRCxJQUFJRyxNQUFNLE9BQU9BLE1BQU0sMkNBQTJDO0lBRWxFLElBQUlOLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztRQXBDdkIsS0FxQ3lDLEdBQUdiLHdEQUFPQSxDQUFDLE9BQU8sd0JBQXdCYSxRQUFRLENBQU07SUFDL0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxJQUFJUyxPQUFPLFNBQVNBLEtBQUtDLEtBQUssRUFBRUMsRUFBRTtJQUNoQyxJQUFJQyxTQUFTO0lBRWIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE1BQU1JLE1BQU0sRUFBRUQsSUFBSztRQUNyQyw4REFBOEQ7UUFDOUQsSUFBSUgsS0FBSyxDQUFDRyxFQUFFLEtBQUssY0FBYztRQUMvQixJQUFJRCxRQUFRQSxVQUFVRDtRQUN0QkMsVUFBVUYsS0FBSyxDQUFDRyxFQUFFO0lBQ3BCO0lBRUEsT0FBT0Q7QUFDVDtBQUNBOzs7Ozs7O0NBT0MsR0FHRCxJQUFJRyxhQUFhLFNBQVNBLFdBQVdMLEtBQUs7SUFDeEMsSUFBSSxDQUFDZCxNQUFNQyxPQUFPLENBQUNhLFFBQVEsT0FBT0E7SUFDbEMsSUFBSU0sV0FBVyxJQUFJLDBEQUEwRDtJQUU3RSxJQUFJcEIsTUFBTUMsT0FBTyxDQUFDYSxLQUFLLENBQUMsRUFBRSxHQUFHO1FBQzNCLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJSCxNQUFNSSxNQUFNLEVBQUVELElBQUs7WUFDckMsSUFBSUgsS0FBSyxDQUFDRyxFQUFFLEtBQUssY0FBYztZQUMvQixJQUFJRyxVQUFVQSxZQUFZO1lBQzFCQSxZQUFZUCxLQUFLQyxLQUFLLENBQUNHLEVBQUUsRUFBRTtRQUM3QjtJQUNGLE9BQU9HLFdBQVdQLEtBQUtDLE9BQU8sT0FBTywwQ0FBMEM7SUFHL0UsSUFBSUEsS0FBSyxDQUFDQSxNQUFNSSxNQUFNLEdBQUcsRUFBRSxLQUFLLGNBQWM7UUFDNUNFLFlBQVk7SUFDZDtJQUVBLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTQyxxQkFBcUJkLE9BQU87SUFDbkMsSUFBSUEsV0FBV0EsUUFBUWUsTUFBTSxLQUFLLE9BQU87UUFDdkMsT0FBTztZQUNMQyxXQUFXO1lBQ1hDLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztRQUNMRCxXQUFXO1FBQ1hDLE9BQU87SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBRUQsU0FBU0MsVUFBVUMsR0FBRyxFQUFFQyxNQUFNO0lBQzVCLElBQUlYLFNBQVM7SUFFYixJQUFLLElBQUlZLFFBQVEsR0FBR0EsUUFBUUQsUUFBUUMsUUFBUztRQUMzQ1osVUFBVTtJQUNaO0lBRUEsT0FBT0EsU0FBU1U7QUFDbEI7QUFDQTs7Q0FFQyxHQUdELFNBQVNHLE1BQU1DLFFBQVEsRUFBRS9CLEtBQUssRUFBRVEsT0FBTztJQUNyQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFFQSxJQUFJUyxTQUFTO0lBQ2IsSUFBSSxDQUFDakIsT0FBTyxPQUFPaUI7SUFDbkIsSUFBSWUsV0FBV3hCLFNBQ1h5QixrQkFBa0JELFNBQVNKLE1BQU0sRUFDakNBLFNBQVNLLG9CQUFvQixLQUFLLElBQUksSUFBSUE7SUFDOUMsSUFBSUMsWUFBWWxDLE1BQU1rQyxTQUFTO0lBRS9CLElBQUkxQixRQUFRZSxNQUFNLEtBQUssT0FBTztRQUM1QkssU0FBUyxDQUFDTztJQUNaO0lBRUEsSUFBSUMsd0JBQXdCZCxxQkFBcUJkLFVBQzdDZ0IsWUFBWVksc0JBQXNCWixTQUFTLEVBQzNDQyxRQUFRVyxzQkFBc0JYLEtBQUs7SUFFdkMsSUFBSU0sVUFBVUgsVUFBVSx5QkFBeUI7SUFFakQsSUFBSU0sV0FBVztRQUNiLDRDQUE0QztRQUM1QyxJQUFJakMsTUFBTUMsT0FBTyxDQUFDZ0MsWUFBWTtZQUM1QixJQUFLLElBQUlMLFFBQVEsR0FBR0EsUUFBUUssVUFBVWYsTUFBTSxFQUFFVSxRQUFTO2dCQUNyRCxJQUFJUSxXQUFXSCxTQUFTLENBQUNMLE1BQU07Z0JBRS9CLElBQUssSUFBSVMsUUFBUUQsU0FBVTtvQkFDekIsSUFBSXRCLFFBQVFzQixRQUFRLENBQUNDLEtBQUs7b0JBRTFCLElBQUl2QixTQUFTLE1BQU07d0JBQ2pCLElBQUlFLFFBQVFBLFVBQVVPO3dCQUN0QlAsVUFBVVMsVUFBVVksT0FBTyxNQUFNYixRQUFRTCxXQUFXTCxTQUFTLEtBQUthO29CQUNwRTtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLDJDQUEyQztZQUMzQyxJQUFLLElBQUlXLFNBQVNMLFVBQVc7Z0JBQzNCLElBQUlNLFNBQVNOLFNBQVMsQ0FBQ0ssTUFBTTtnQkFFN0IsSUFBSUMsVUFBVSxNQUFNO29CQUNsQixJQUFJdkIsUUFBUUEsVUFBVU87b0JBQ3RCUCxVQUFVUyxVQUFVYSxRQUFRLE1BQU1kLFFBQVFMLFdBQVdvQixVQUFVLEtBQUtaO2dCQUN0RTtZQUNGO1FBQ0Y7SUFDRjtJQUVBLElBQUssSUFBSWEsVUFBVXpDLE1BQU87UUFDeEIsSUFBSTBDLFVBQVUxQyxLQUFLLENBQUN5QyxPQUFPO1FBRTNCLElBQUlDLFdBQVcsUUFBUUQsV0FBVyxhQUFhO1lBQzdDLElBQUl4QixRQUFRQSxVQUFVTztZQUN0QlAsVUFBVVMsVUFBVWUsU0FBUyxNQUFNaEIsUUFBUUwsV0FBV3NCLFdBQVcsS0FBS2Q7UUFDeEU7SUFDRixFQUFFLGdGQUFnRjtJQUdsRixJQUFJLENBQUNYLFVBQVUsQ0FBQ1QsUUFBUW1DLFVBQVUsRUFBRSxPQUFPMUIsUUFBUSw4REFBOEQ7SUFFakgsSUFBSSxDQUFDYyxVQUFVLE9BQU9kO0lBQ3RCVztJQUNBLElBQUlYLFFBQVFBLFNBQVMsS0FBS08sWUFBWVAsU0FBU087SUFDL0MsT0FBT0UsVUFBVSxLQUFLSyxXQUFXTixRQUFRLE1BQU1SLFFBQVFXLFVBQVVGLFVBQVUsS0FBS0U7QUFDbEY7QUFFQSxJQUFJZ0IsY0FBYztBQUNsQixJQUFJQyxlQUFlLE9BQU9DLFFBQVEsZUFBZUEsSUFBSUMsTUFBTTtBQUMzRCxJQUFJQSxTQUFVLFNBQVVwQixHQUFHO0lBQ3pCLE9BQU9rQixlQUFlQSxhQUFhbEIsT0FBT0EsSUFBSXFCLE9BQU8sQ0FBQ0osYUFBYTtBQUNyRTtBQUVBLElBQUlLLGdCQUNKLFdBQVcsR0FDWDtJQUNFLFNBQVNBLGNBQWNDLEdBQUcsRUFBRWxELEtBQUssRUFBRVEsT0FBTztRQUN4QyxJQUFJLENBQUMyQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJQyxRQUFRN0MsUUFBUTZDLEtBQUssRUFDckJDLFdBQVc5QyxRQUFROEMsUUFBUTtRQUMvQixJQUFJLENBQUNKLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUMxQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDUixLQUFLLEdBQUdBO1FBQ2IsSUFBSXFELE9BQU8sSUFBSSxDQUFDRSxRQUFRLEdBQUdGLE1BQU1FLFFBQVE7YUFBTSxJQUFJRCxVQUFVLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlEO0lBQ25GO0lBQ0E7O0dBRUMsR0FHRCxJQUFJRSxTQUFTUCxjQUFjUSxTQUFTO0lBRXBDRCxPQUFPbEIsSUFBSSxHQUFHLFNBQVNBLEtBQUtqQyxJQUFJLEVBQUVVLEtBQUssRUFBRVAsT0FBTztRQUM5QyxpQkFBaUI7UUFDakIsSUFBSU8sVUFBVTJDLFdBQVcsT0FBTyxJQUFJLENBQUMxRCxLQUFLLENBQUNLLEtBQUssRUFBRSxrREFBa0Q7UUFFcEcsSUFBSXNELFFBQVFuRCxVQUFVQSxRQUFRbUQsS0FBSyxHQUFHO1FBQ3RDLElBQUksQ0FBQ0EsU0FBUyxJQUFJLENBQUMzRCxLQUFLLENBQUNLLEtBQUssS0FBS1UsT0FBTyxPQUFPLElBQUk7UUFDckQsSUFBSTZDLFdBQVc3QztRQUVmLElBQUksQ0FBQ1AsV0FBV0EsUUFBUXFELE9BQU8sS0FBSyxPQUFPO1lBQ3pDRCxXQUFXLElBQUksQ0FBQ3BELE9BQU8sQ0FBQ0MsR0FBRyxDQUFDRyxPQUFPLENBQUNrRCxhQUFhLENBQUMvQyxPQUFPVixNQUFNLElBQUk7UUFDckU7UUFFQSxJQUFJMEQsVUFBVUgsWUFBWSxRQUFRQSxhQUFhO1FBQy9DLElBQUlJLFlBQVkzRCxRQUFRLElBQUksQ0FBQ0wsS0FBSyxFQUFFLDRDQUE0QztRQUVoRixJQUFJK0QsV0FBVyxDQUFDQyxhQUFhLENBQUNMLE9BQU8sT0FBTyxJQUFJLEVBQUUscUNBQXFDO1FBRXZGLElBQUlNLFNBQVNGLFdBQVdDO1FBQ3hCLElBQUlDLFFBQVEsT0FBTyxJQUFJLENBQUNqRSxLQUFLLENBQUNLLEtBQUs7YUFBTSxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssS0FBSyxHQUFHdUQsVUFBVSw2REFBNkQ7UUFFbkksSUFBSSxJQUFJLENBQUNNLFVBQVUsSUFBSSxJQUFJLENBQUNYLFFBQVEsRUFBRTtZQUNwQyxJQUFJVSxRQUFRLElBQUksQ0FBQ1YsUUFBUSxDQUFDWSxjQUFjLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUU3RDtpQkFBVyxJQUFJLENBQUNrRCxRQUFRLENBQUNhLFdBQVcsQ0FBQyxJQUFJLENBQUNGLFVBQVUsRUFBRTdELE1BQU11RDtZQUN0SCxPQUFPLElBQUk7UUFDYjtRQUVBLElBQUlQLFFBQVEsSUFBSSxDQUFDN0MsT0FBTyxDQUFDNkMsS0FBSztRQUU5QixJQUFJQSxTQUFTQSxNQUFNZ0IsUUFBUSxFQUFFO1lBL09qQyxLQWdQMkMsR0FBRzdFLHdEQUFPQSxDQUFDLE9BQU8sa0VBQWtFLENBQU07UUFDakk7UUFFQSxPQUFPLElBQUk7SUFDYjtJQUVBLE9BQU95RDtBQUNUO0FBQ0EsSUFBSXFCLFlBQ0osV0FBVyxHQUNYLFNBQVVDLGNBQWM7SUFDdEI3RSxvRkFBY0EsQ0FBQzRFLFdBQVdDO0lBRTFCLFNBQVNELFVBQVVwQixHQUFHLEVBQUVsRCxLQUFLLEVBQUVRLE9BQU87UUFDcEMsSUFBSWdFO1FBRUpBLFFBQVFELGVBQWVFLElBQUksQ0FBQyxJQUFJLEVBQUV2QixLQUFLbEQsT0FBT1EsWUFBWSxJQUFJO1FBQzlELElBQUl1QixXQUFXdkIsUUFBUXVCLFFBQVEsRUFDM0IyQyxTQUFTbEUsUUFBUWtFLE1BQU0sRUFDdkJyQixRQUFRN0MsUUFBUTZDLEtBQUssRUFDckJzQixhQUFhbkUsUUFBUW1FLFVBQVU7UUFFbkMsSUFBSTVDLFVBQVU7WUFDWnlDLE1BQU1JLFlBQVksR0FBRzdDO1FBQ3ZCLE9BQU8sSUFBSTJDLFdBQVcsT0FBTztZQUMzQkYsTUFBTUssRUFBRSxHQUFHRixXQUFXaEYsNEZBQXNCQSxDQUFDQSw0RkFBc0JBLENBQUM2RSxTQUFTbkI7WUFDN0VtQixNQUFNSSxZQUFZLEdBQUcsTUFBTTdCLE9BQU95QixNQUFNSyxFQUFFO1FBQzVDO1FBRUEsT0FBT0w7SUFDVDtJQUNBOzs7O0dBSUMsR0FHRCxJQUFJTSxVQUFVUixVQUFVYixTQUFTO0lBRWpDOztHQUVDLEdBQ0RxQixRQUFRQyxPQUFPLEdBQUcsU0FBU0EsUUFBUWIsVUFBVTtRQUMzQyxJQUFJWCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUU1QixJQUFJQSxVQUFVO1lBQ1osSUFBSXlCLE9BQU8sSUFBSSxDQUFDQyxNQUFNO1lBRXRCLElBQUssSUFBSTNDLFFBQVEwQyxLQUFNO2dCQUNyQnpCLFNBQVNhLFdBQVcsQ0FBQ0YsWUFBWTVCLE1BQU0wQyxJQUFJLENBQUMxQyxLQUFLO1lBQ25EO1FBQ0Y7UUFFQSxPQUFPLElBQUk7SUFDYixFQUNBOzs7O0dBSUM7SUFHRHdDLFFBQVFHLE1BQU0sR0FBRyxTQUFTQTtRQUN4QixJQUFJRCxPQUFPLENBQUM7UUFFWixJQUFLLElBQUkxQyxRQUFRLElBQUksQ0FBQ3RDLEtBQUssQ0FBRTtZQUMzQixJQUFJZSxRQUFRLElBQUksQ0FBQ2YsS0FBSyxDQUFDc0MsS0FBSztZQUM1QixJQUFJLE9BQU92QixVQUFVLFVBQVVpRSxJQUFJLENBQUMxQyxLQUFLLEdBQUd2QjtpQkFBVyxJQUFJZCxNQUFNQyxPQUFPLENBQUNhLFFBQVFpRSxJQUFJLENBQUMxQyxLQUFLLEdBQUdsQixXQUFXTDtRQUMzRztRQUVBLE9BQU9pRTtJQUNULEVBQ0E7O0dBRUM7SUFHREYsUUFBUUksUUFBUSxHQUFHLFNBQVNBLFNBQVMxRSxPQUFPO1FBQzFDLElBQUk2QyxRQUFRLElBQUksQ0FBQzdDLE9BQU8sQ0FBQzZDLEtBQUs7UUFDOUIsSUFBSThCLE9BQU85QixRQUFRQSxNQUFNN0MsT0FBTyxDQUFDMkUsSUFBSSxHQUFHO1FBQ3hDLElBQUlDLE9BQU9ELE9BQU83Riw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdrQixTQUFTO1lBQ3RDbUMsWUFBWTtRQUNkLEtBQUtuQztRQUNMLE9BQU9zQixNQUFNLElBQUksQ0FBQzhDLFlBQVksRUFBRSxJQUFJLENBQUM1RSxLQUFLLEVBQUVvRjtJQUM5QztJQUVBM0Ysa0ZBQVlBLENBQUM2RSxXQUFXO1FBQUM7WUFDdkJwQixLQUFLO1lBQ0xtQyxLQUFLLFNBQVNBLElBQUl0RCxRQUFRO2dCQUN4QixJQUFJQSxhQUFhLElBQUksQ0FBQzZDLFlBQVksRUFBRTtnQkFDcEMsSUFBSSxDQUFDQSxZQUFZLEdBQUc3QztnQkFDcEIsSUFBSXdCLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEVBQ3hCVyxhQUFhLElBQUksQ0FBQ0EsVUFBVTtnQkFDaEMsSUFBSSxDQUFDQSxjQUFjLENBQUNYLFVBQVU7Z0JBQzlCLElBQUkrQixhQUFhL0IsU0FBU2dDLFdBQVcsQ0FBQ3JCLFlBQVluQyxXQUFXLDREQUE0RDtnQkFFekgsSUFBSSxDQUFDdUQsWUFBWTtvQkFDZi9CLFNBQVNpQyxXQUFXLENBQUN0QixZQUFZLElBQUk7Z0JBQ3ZDO1lBQ0Y7WUFLQXVCLEtBQUssU0FBU0E7Z0JBQ1osT0FBTyxJQUFJLENBQUNiLFlBQVk7WUFDMUI7UUFDRjtLQUFFO0lBRUYsT0FBT047QUFDVCxFQUFFckI7QUFDRixJQUFJeUMsa0JBQWtCO0lBQ3BCN0UsY0FBYyxTQUFTQSxhQUFhcUMsR0FBRyxFQUFFbEQsS0FBSyxFQUFFUSxPQUFPO1FBQ3JELElBQUkwQyxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU8xQyxRQUFRbUYsTUFBTSxJQUFJbkYsUUFBUW1GLE1BQU0sQ0FBQ3hDLElBQUksS0FBSyxhQUFhO1lBQzNFLE9BQU87UUFDVDtRQUVBLE9BQU8sSUFBSW1CLFVBQVVwQixLQUFLbEQsT0FBT1E7SUFDbkM7QUFDRjtBQUVBLElBQUlvRix5QkFBeUI7SUFDM0JoRSxRQUFRO0lBQ1JpRSxVQUFVO0FBQ1o7QUFDQSxJQUFJQyxXQUFXO0FBQ2Y7O0NBRUMsR0FFRCxJQUFJQyxrQkFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQSxnQkFBZ0I3QyxHQUFHLEVBQUU4QyxNQUFNLEVBQUV4RixPQUFPO1FBQzNDLElBQUksQ0FBQzJDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUkrQyxVQUFVL0MsSUFBSWdELEtBQUssQ0FBQ0o7UUFDeEIsSUFBSSxDQUFDSyxFQUFFLEdBQUdGLFVBQVVBLE9BQU8sQ0FBQyxFQUFFLEdBQUcsV0FBVyxxRkFBcUY7UUFFakksSUFBSSxDQUFDRyxLQUFLLEdBQUc1RixRQUFRSCxJQUFJLElBQUksTUFBTSxJQUFJLENBQUM4RixFQUFFO1FBQzFDLElBQUksQ0FBQzNGLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUM2RixLQUFLLEdBQUcsSUFBSUMsU0FBU2hILDhFQUFRQSxDQUFDLENBQUMsR0FBR2tCLFNBQVM7WUFDOUNtRixRQUFRLElBQUk7UUFDZDtRQUVBLElBQUssSUFBSXRGLFFBQVEyRixPQUFRO1lBQ3ZCLElBQUksQ0FBQ0ssS0FBSyxDQUFDRSxHQUFHLENBQUNsRyxNQUFNMkYsTUFBTSxDQUFDM0YsS0FBSztRQUNuQztRQUVBLElBQUksQ0FBQ2dHLEtBQUssQ0FBQ3hDLE9BQU87SUFDcEI7SUFDQTs7R0FFQyxHQUdELElBQUlMLFNBQVN1QyxnQkFBZ0J0QyxTQUFTO0lBRXRDRCxPQUFPZ0QsT0FBTyxHQUFHLFNBQVNBLFFBQVFuRyxJQUFJO1FBQ3BDLE9BQU8sSUFBSSxDQUFDZ0csS0FBSyxDQUFDWixHQUFHLENBQUNwRjtJQUN4QixFQUNBOztHQUVDO0lBR0RtRCxPQUFPaUQsT0FBTyxHQUFHLFNBQVNBLFFBQVE5RixJQUFJO1FBQ3BDLE9BQU8sSUFBSSxDQUFDMEYsS0FBSyxDQUFDSSxPQUFPLENBQUM5RjtJQUM1QixFQUNBOztHQUVDO0lBR0Q2QyxPQUFPa0QsT0FBTyxHQUFHLFNBQVNBLFFBQVFyRyxJQUFJLEVBQUVMLEtBQUssRUFBRVEsT0FBTztRQUNwRCxJQUFJRyxPQUFPLElBQUksQ0FBQzBGLEtBQUssQ0FBQ0UsR0FBRyxDQUFDbEcsTUFBTUwsT0FBT1E7UUFDdkMsSUFBSSxDQUFDRyxNQUFNLE9BQU87UUFDbEIsSUFBSSxDQUFDSCxPQUFPLENBQUNDLEdBQUcsQ0FBQ0csT0FBTyxDQUFDK0YsYUFBYSxDQUFDaEc7UUFDdkMsT0FBT0E7SUFDVCxFQUNBOztHQUVDO0lBR0Q2QyxPQUFPZ0MsV0FBVyxHQUFHLFNBQVNBLFlBQVluRixJQUFJLEVBQUVMLEtBQUssRUFBRVEsT0FBTztRQUM1RCxJQUFJb0csVUFBVSxJQUFJLENBQUNQLEtBQUssQ0FBQ3JELE9BQU8sQ0FBQzNDLE1BQU1MLE9BQU9RO1FBQzlDLElBQUlvRyxTQUFTLElBQUksQ0FBQ3BHLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDRyxPQUFPLENBQUMrRixhQUFhLENBQUNDO1FBQ3BELE9BQU9BO0lBQ1QsRUFDQTs7R0FFQztJQUdEcEQsT0FBTzBCLFFBQVEsR0FBRyxTQUFTQSxTQUFTMUUsT0FBTztRQUN6QyxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUN0QkEsVUFBVW9GO1FBQ1o7UUFFQSxJQUFJeEQsd0JBQXdCZCxxQkFBcUJkLFVBQzdDZ0IsWUFBWVksc0JBQXNCWixTQUFTO1FBRS9DLElBQUloQixRQUFRb0IsTUFBTSxJQUFJLE1BQU1wQixRQUFRb0IsTUFBTSxHQUFHZ0UsdUJBQXVCaEUsTUFBTTtRQUMxRSxJQUFJcEIsUUFBUXFGLFFBQVEsSUFBSSxNQUFNckYsUUFBUXFGLFFBQVEsR0FBR0QsdUJBQXVCQyxRQUFRO1FBRWhGLElBQUlyRixRQUFRcUYsUUFBUSxLQUFLLE9BQU87WUFDOUIsT0FBTyxJQUFJLENBQUNPLEtBQUssR0FBRztRQUN0QjtRQUVBLElBQUlQLFdBQVcsSUFBSSxDQUFDUSxLQUFLLENBQUNuQixRQUFRLENBQUMxRTtRQUNuQyxPQUFPcUYsV0FBVyxJQUFJLENBQUNPLEtBQUssR0FBRyxPQUFPNUUsWUFBWXFFLFdBQVdyRSxZQUFZLE1BQU07SUFDakY7SUFFQSxPQUFPdUU7QUFDVDtBQUNBLElBQUljLFlBQVk7QUFDaEIsSUFBSUMsd0JBQXdCO0lBQzFCakcsY0FBYyxTQUFTQSxhQUFhcUMsR0FBRyxFQUFFOEMsTUFBTSxFQUFFeEYsT0FBTztRQUN0RCxPQUFPcUcsVUFBVUUsSUFBSSxDQUFDN0QsT0FBTyxJQUFJNkMsZ0JBQWdCN0MsS0FBSzhDLFFBQVF4RixXQUFXO0lBQzNFO0FBQ0Y7QUFFQSxJQUFJd0csMkJBQTJCO0lBQzdCcEYsUUFBUTtJQUNSaUUsVUFBVTtBQUNaO0FBQ0EsSUFBSW9CLGFBQWE7QUFDakI7O0NBRUMsR0FFRCxJQUFJQyxnQkFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQSxjQUFjaEUsR0FBRyxFQUFFaUUsTUFBTSxFQUFFM0csT0FBTztRQUN6QyxJQUFJLENBQUMyQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNnRCxFQUFFLEdBQUc7UUFDVixJQUFJLENBQUMvQyxXQUFXLEdBQUc7UUFDbkIsSUFBSWdFLFlBQVlsRSxJQUFJZ0QsS0FBSyxDQUFDZTtRQUUxQixJQUFJRyxhQUFhQSxTQUFTLENBQUMsRUFBRSxFQUFFO1lBQzdCLElBQUksQ0FBQy9HLElBQUksR0FBRytHLFNBQVMsQ0FBQyxFQUFFO1FBQzFCLE9BQU87WUFDTCxJQUFJLENBQUMvRyxJQUFJLEdBQUc7WUF0ZWxCLEtBdWUyQyxHQUFHYix3REFBT0EsQ0FBQyxPQUFPLDhCQUE4QjBELE9BQU8sQ0FBTTtRQUNwRztRQUVBLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUksQ0FBQ0MsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDOUMsSUFBSTtRQUN0QyxJQUFJLENBQUNHLE9BQU8sR0FBR0E7UUFDZixJQUFJa0UsU0FBU2xFLFFBQVFrRSxNQUFNLEVBQ3ZCckIsUUFBUTdDLFFBQVE2QyxLQUFLLEVBQ3JCc0IsYUFBYW5FLFFBQVFtRSxVQUFVO1FBQ25DLElBQUksQ0FBQ0UsRUFBRSxHQUFHSCxXQUFXLFFBQVEsSUFBSSxDQUFDckUsSUFBSSxHQUFHMEMsT0FBTzRCLFdBQVcsSUFBSSxFQUFFdEI7UUFDakUsSUFBSSxDQUFDZ0QsS0FBSyxHQUFHLElBQUlDLFNBQVNoSCw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdrQixTQUFTO1lBQzlDbUYsUUFBUSxJQUFJO1FBQ2Q7UUFFQSxJQUFLLElBQUl0RixRQUFROEcsT0FBUTtZQUN2QixJQUFJLENBQUNkLEtBQUssQ0FBQ0UsR0FBRyxDQUFDbEcsTUFBTThHLE1BQU0sQ0FBQzlHLEtBQUssRUFBRWYsOEVBQVFBLENBQUMsQ0FBQyxHQUFHa0IsU0FBUztnQkFDdkRtRixRQUFRLElBQUk7WUFDZDtRQUNGO1FBRUEsSUFBSSxDQUFDVSxLQUFLLENBQUN4QyxPQUFPO0lBQ3BCO0lBQ0E7O0dBRUMsR0FHRCxJQUFJTCxTQUFTMEQsY0FBY3pELFNBQVM7SUFFcENELE9BQU8wQixRQUFRLEdBQUcsU0FBU0EsU0FBUzFFLE9BQU87UUFDekMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFDdEJBLFVBQVV3RztRQUNaO1FBRUEsSUFBSTVFLHdCQUF3QmQscUJBQXFCZCxVQUM3Q2dCLFlBQVlZLHNCQUFzQlosU0FBUztRQUUvQyxJQUFJaEIsUUFBUW9CLE1BQU0sSUFBSSxNQUFNcEIsUUFBUW9CLE1BQU0sR0FBR29GLHlCQUF5QnBGLE1BQU07UUFDNUUsSUFBSXBCLFFBQVFxRixRQUFRLElBQUksTUFBTXJGLFFBQVFxRixRQUFRLEdBQUdtQix5QkFBeUJuQixRQUFRO1FBRWxGLElBQUlyRixRQUFRcUYsUUFBUSxLQUFLLE9BQU87WUFDOUIsT0FBTyxJQUFJLENBQUNNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ3RCLEVBQUUsR0FBRztRQUNuQztRQUVBLElBQUlnQixXQUFXLElBQUksQ0FBQ1EsS0FBSyxDQUFDbkIsUUFBUSxDQUFDMUU7UUFDbkMsSUFBSXFGLFVBQVVBLFdBQVcsS0FBS3JFLFlBQVlxRSxXQUFXckU7UUFDckQsT0FBTyxJQUFJLENBQUMyRSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUN0QixFQUFFLEdBQUcsT0FBT2dCLFdBQVc7SUFDckQ7SUFFQSxPQUFPcUI7QUFDVDtBQUNBLElBQUlHLGNBQWM7QUFDbEIsSUFBSUMsWUFBWTtBQUVoQixJQUFJQyx5QkFBeUIsU0FBU0EsdUJBQXVCQyxHQUFHLEVBQUVDLFNBQVM7SUFDekUsSUFBSSxPQUFPRCxRQUFRLFVBQVU7UUFDM0IsT0FBT0EsSUFBSXhFLE9BQU8sQ0FBQ3NFLFdBQVcsU0FBVXBCLEtBQUssRUFBRTdGLElBQUk7WUFDakQsSUFBSUEsUUFBUW9ILFdBQVc7Z0JBQ3JCLE9BQU9BLFNBQVMsQ0FBQ3BILEtBQUs7WUFDeEI7WUFqaUJOLEtBbWlCMkMsR0FBR2Isd0RBQU9BLENBQUMsT0FBTyxzQ0FBdUNhLE9BQU8sdUJBQXdCLENBQU07WUFDbkksT0FBTzZGO1FBQ1Q7SUFDRjtJQUVBLE9BQU9zQjtBQUNUO0FBQ0E7O0NBRUMsR0FHRCxJQUFJRSxhQUFhLFNBQVNBLFdBQVcxSCxLQUFLLEVBQUVzQyxJQUFJLEVBQUVtRixTQUFTO0lBQ3pELElBQUkxRyxRQUFRZixLQUFLLENBQUNzQyxLQUFLO0lBQ3ZCLElBQUlxRixjQUFjSix1QkFBdUJ4RyxPQUFPMEc7SUFFaEQsSUFBSUUsZ0JBQWdCNUcsT0FBTztRQUN6QmYsS0FBSyxDQUFDc0MsS0FBSyxHQUFHcUY7SUFDaEI7QUFDRjtBQUVBLElBQUlDLHNCQUFzQjtJQUN4Qi9HLGNBQWMsU0FBU0EsYUFBYXFDLEdBQUcsRUFBRWlFLE1BQU0sRUFBRTNHLE9BQU87UUFDdEQsT0FBTyxPQUFPMEMsUUFBUSxZQUFZbUUsWUFBWU4sSUFBSSxDQUFDN0QsT0FBTyxJQUFJZ0UsY0FBY2hFLEtBQUtpRSxRQUFRM0csV0FBVztJQUN0RztJQUNBLCtCQUErQjtJQUMvQnFILGdCQUFnQixTQUFTQSxlQUFlN0gsS0FBSyxFQUFFVyxJQUFJLEVBQUUwQyxLQUFLO1FBQ3hELElBQUkxQyxLQUFLd0MsSUFBSSxLQUFLLFdBQVcsQ0FBQ0UsT0FBTyxPQUFPckQ7UUFDNUMsSUFBSSxvQkFBb0JBLE9BQU8wSCxXQUFXMUgsT0FBTyxrQkFBa0JxRCxNQUFNb0UsU0FBUztRQUNsRixJQUFJLGVBQWV6SCxPQUFPMEgsV0FBVzFILE9BQU8sYUFBYXFELE1BQU1vRSxTQUFTO1FBQ3hFLE9BQU96SDtJQUNUO0lBQ0E4RCxlQUFlLFNBQVNBLGNBQWMwRCxHQUFHLEVBQUVsRixJQUFJLEVBQUUzQixJQUFJO1FBQ25ELElBQUkwQyxRQUFRMUMsS0FBS0gsT0FBTyxDQUFDNkMsS0FBSztRQUU5QixJQUFJLENBQUNBLE9BQU87WUFDVixPQUFPbUU7UUFDVDtRQUVBLE9BQVFsRjtZQUNOLEtBQUs7Z0JBQ0gsT0FBT2lGLHVCQUF1QkMsS0FBS25FLE1BQU1vRSxTQUFTO1lBRXBELEtBQUs7Z0JBQ0gsT0FBT0YsdUJBQXVCQyxLQUFLbkUsTUFBTW9FLFNBQVM7WUFFcEQ7Z0JBQ0UsT0FBT0Q7UUFDWDtJQUNGO0FBQ0Y7QUFFQSxJQUFJTSxlQUNKLFdBQVcsR0FDWCxTQUFVdkQsY0FBYztJQUN0QjdFLG9GQUFjQSxDQUFDb0ksY0FBY3ZEO0lBRTdCLFNBQVN1RDtRQUNQLE9BQU92RCxlQUFld0QsS0FBSyxDQUFDLElBQUksRUFBRUMsY0FBYyxJQUFJO0lBQ3REO0lBRUEsSUFBSXhFLFNBQVNzRSxhQUFhckUsU0FBUztJQUVuQzs7R0FFQyxHQUNERCxPQUFPMEIsUUFBUSxHQUFHLFNBQVNBLFNBQVMxRSxPQUFPO1FBQ3pDLElBQUk2QyxRQUFRLElBQUksQ0FBQzdDLE9BQU8sQ0FBQzZDLEtBQUs7UUFDOUIsSUFBSThCLE9BQU85QixRQUFRQSxNQUFNN0MsT0FBTyxDQUFDMkUsSUFBSSxHQUFHO1FBQ3hDLElBQUlDLE9BQU9ELE9BQU83Riw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdrQixTQUFTO1lBQ3RDbUMsWUFBWTtRQUNkLEtBQUtuQztRQUNMLE9BQU9zQixNQUFNLElBQUksQ0FBQ29CLEdBQUcsRUFBRSxJQUFJLENBQUNsRCxLQUFLLEVBQUVvRjtJQUNyQztJQUVBLE9BQU8wQztBQUNULEVBQUU3RTtBQUNGLElBQUlnRixxQkFBcUI7SUFDdkJwSCxjQUFjLFNBQVNBLGFBQWFxQyxHQUFHLEVBQUVsRCxLQUFLLEVBQUVRLE9BQU87UUFDckQsSUFBSUEsUUFBUW1GLE1BQU0sSUFBSW5GLFFBQVFtRixNQUFNLENBQUN4QyxJQUFJLEtBQUssYUFBYTtZQUN6RCxPQUFPLElBQUkyRSxhQUFhNUUsS0FBS2xELE9BQU9RO1FBQ3RDO1FBRUEsT0FBTztJQUNUO0FBQ0Y7QUFFQSxJQUFJMEgsZUFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQSxhQUFhaEYsR0FBRyxFQUFFbEQsS0FBSyxFQUFFUSxPQUFPO1FBQ3ZDLElBQUksQ0FBQzJDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2dELEVBQUUsR0FBRztRQUNWLElBQUksQ0FBQy9DLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNsRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDUSxPQUFPLEdBQUdBO0lBQ2pCO0lBQ0E7O0dBRUMsR0FHRCxJQUFJZ0QsU0FBUzBFLGFBQWF6RSxTQUFTO0lBRW5DRCxPQUFPMEIsUUFBUSxHQUFHLFNBQVNBLFNBQVMxRSxPQUFPO1FBQ3pDLElBQUk0Qix3QkFBd0JkLHFCQUFxQmQsVUFDN0NnQixZQUFZWSxzQkFBc0JaLFNBQVM7UUFFL0MsSUFBSXZCLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLEtBQUssR0FBRztZQUM3QixJQUFJMkIsTUFBTTtZQUVWLElBQUssSUFBSUUsUUFBUSxHQUFHQSxRQUFRLElBQUksQ0FBQzdCLEtBQUssQ0FBQ21CLE1BQU0sRUFBRVUsUUFBUztnQkFDdERGLE9BQU9HLE1BQU0sSUFBSSxDQUFDcUUsRUFBRSxFQUFFLElBQUksQ0FBQ25HLEtBQUssQ0FBQzZCLE1BQU07Z0JBQ3ZDLElBQUksSUFBSSxDQUFDN0IsS0FBSyxDQUFDNkIsUUFBUSxFQUFFLEVBQUVGLE9BQU9IO1lBQ3BDO1lBRUEsT0FBT0c7UUFDVDtRQUVBLE9BQU9HLE1BQU0sSUFBSSxDQUFDcUUsRUFBRSxFQUFFLElBQUksQ0FBQ25HLEtBQUssRUFBRVE7SUFDcEM7SUFFQSxPQUFPMEg7QUFDVDtBQUNBLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMscUJBQXFCO0lBQ3ZCdkgsY0FBYyxTQUFTQSxhQUFhcUMsR0FBRyxFQUFFbEQsS0FBSyxFQUFFUSxPQUFPO1FBQ3JELE9BQU8ySCxZQUFZcEIsSUFBSSxDQUFDN0QsT0FBTyxJQUFJZ0YsYUFBYWhGLEtBQUtsRCxPQUFPUSxXQUFXO0lBQ3pFO0FBQ0Y7QUFFQSxJQUFJNkgsZUFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQSxhQUFhbkYsR0FBRyxFQUFFbEQsS0FBSyxFQUFFUSxPQUFPO1FBQ3ZDLElBQUksQ0FBQzJDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2dELEVBQUUsR0FBRztRQUNWLElBQUksQ0FBQy9DLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNsRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDUSxPQUFPLEdBQUdBO0lBQ2pCO0lBQ0E7O0dBRUMsR0FHRCxJQUFJZ0QsU0FBUzZFLGFBQWE1RSxTQUFTO0lBRW5DRCxPQUFPMEIsUUFBUSxHQUFHLFNBQVNBLFNBQVMxRSxPQUFPO1FBQ3pDLE9BQU9zQixNQUFNLElBQUksQ0FBQ29CLEdBQUcsRUFBRSxJQUFJLENBQUNsRCxLQUFLLEVBQUVRO0lBQ3JDO0lBRUEsT0FBTzZIO0FBQ1Q7QUFDQSxJQUFJQyxxQkFBcUI7SUFDdkJ6SCxjQUFjLFNBQVNBLGFBQWFxQyxHQUFHLEVBQUVsRCxLQUFLLEVBQUVRLE9BQU87UUFDckQsT0FBTzBDLFFBQVEsZUFBZUEsUUFBUSxrQkFBa0IsSUFBSW1GLGFBQWFuRixLQUFLbEQsT0FBT1EsV0FBVztJQUNsRztBQUNGO0FBRUEsSUFBSStILGFBQ0osV0FBVyxHQUNYO0lBQ0UsU0FBU0EsV0FBV3JGLEdBQUcsRUFBRW5DLEtBQUssRUFBRVAsT0FBTztRQUNyQyxJQUFJLENBQUMyQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNuQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDUCxPQUFPLEdBQUdBO0lBQ2pCO0lBQ0E7O0dBRUMsR0FDRCwwQ0FBMEM7SUFHMUMsSUFBSWdELFNBQVMrRSxXQUFXOUUsU0FBUztJQUVqQ0QsT0FBTzBCLFFBQVEsR0FBRyxTQUFTQSxTQUFTMUUsT0FBTztRQUN6QyxJQUFJUCxNQUFNQyxPQUFPLENBQUMsSUFBSSxDQUFDYSxLQUFLLEdBQUc7WUFDN0IsSUFBSVksTUFBTTtZQUVWLElBQUssSUFBSUUsUUFBUSxHQUFHQSxRQUFRLElBQUksQ0FBQ2QsS0FBSyxDQUFDSSxNQUFNLEVBQUVVLFFBQVM7Z0JBQ3RERixPQUFPLElBQUksQ0FBQ3VCLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQ25DLEtBQUssQ0FBQ2MsTUFBTSxHQUFHO2dCQUM1QyxJQUFJLElBQUksQ0FBQ2QsS0FBSyxDQUFDYyxRQUFRLEVBQUUsRUFBRUYsT0FBTztZQUNwQztZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxPQUFPLElBQUksQ0FBQ3VCLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQ25DLEtBQUssR0FBRztJQUN2QztJQUVBLE9BQU93SDtBQUNUO0FBQ0EsSUFBSUMsVUFBVTtJQUNaLFlBQVk7SUFDWixXQUFXO0lBQ1gsY0FBYztBQUNoQjtBQUNBLElBQUlDLG1CQUFtQjtJQUNyQjVILGNBQWMsU0FBU0EsYUFBYXFDLEdBQUcsRUFBRW5DLEtBQUssRUFBRVAsT0FBTztRQUNyRCxPQUFPMEMsT0FBT3NGLFVBQVUsSUFBSUQsV0FBV3JGLEtBQUtuQyxPQUFPUCxXQUFXO0lBQ2hFO0FBQ0Y7QUFFQSxJQUFJSSxVQUFVO0lBQUM4RTtJQUFpQm9CO0lBQXVCYztJQUFxQks7SUFBb0JHO0lBQW9CRTtJQUFvQkc7Q0FBaUI7QUFFekosSUFBSUMsdUJBQXVCO0lBQ3pCN0UsU0FBUztBQUNYO0FBQ0EsSUFBSThFLHFCQUFxQjtJQUN2QmhGLE9BQU87SUFDUEUsU0FBUztBQU1YO0FBRUEsSUFBSXlDLFdBQ0osV0FBVyxHQUNYO0lBQ0UsOENBQThDO0lBQzlDLGdFQUFnRTtJQUNoRSwwQkFBMEI7SUFDMUIsc0NBQXNDO0lBQ3RDLFNBQVNBLFNBQVM5RixPQUFPO1FBQ3ZCLElBQUksQ0FBQ0wsR0FBRyxHQUFHLENBQUM7UUFDWixJQUFJLENBQUN5SSxHQUFHLEdBQUcsQ0FBQztRQUNaLElBQUksQ0FBQy9HLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDZ0gsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDckksT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ3NJLE9BQU8sR0FBR3RJLFFBQVFzSSxPQUFPO1FBQzlCLElBQUksQ0FBQ3JCLFNBQVMsR0FBR2pILFFBQVFpSCxTQUFTO0lBQ3BDO0lBQ0E7Ozs7R0FJQyxHQUdELElBQUlqRSxTQUFTOEMsU0FBUzdDLFNBQVM7SUFFL0JELE9BQU8rQyxHQUFHLEdBQUcsU0FBU0EsSUFBSWxHLElBQUksRUFBRUUsSUFBSSxFQUFFd0ksV0FBVztRQUMvQyxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDeEksT0FBTyxFQUM1Qm1GLFNBQVNxRCxjQUFjckQsTUFBTSxFQUM3QnRDLFFBQVEyRixjQUFjM0YsS0FBSyxFQUMzQjVDLE1BQU11SSxjQUFjdkksR0FBRyxFQUN2QjZDLFdBQVcwRixjQUFjMUYsUUFBUSxFQUNqQ3FCLGFBQWFxRSxjQUFjckUsVUFBVSxFQUNyQ0QsU0FBU3NFLGNBQWN0RSxNQUFNO1FBRWpDLElBQUlsRSxVQUFVbEIsOEVBQVFBLENBQUM7WUFDckJ3SixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQm5ELFFBQVFBO1lBQ1J0QyxPQUFPQTtZQUNQNUMsS0FBS0E7WUFDTDZDLFVBQVVBO1lBQ1ZxQixZQUFZQTtZQUNaRCxRQUFRQTtZQUNSckUsTUFBTUE7WUFDTm9ILFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQ3pCMUYsVUFBVTJCO1FBQ1osR0FBR3FGLGNBQWMsNEVBQTRFO1FBQzdGLGtGQUFrRjtRQUNsRixzRUFBc0U7UUFHdEUsSUFBSTdGLE1BQU03QztRQUVWLElBQUlBLFFBQVEsSUFBSSxDQUFDdUksR0FBRyxFQUFFO1lBQ3BCMUYsTUFBTTdDLE9BQU8sT0FBTyxJQUFJLENBQUN3SSxPQUFPO1FBQ2xDLEVBQUUsNkRBQTZEO1FBQy9ELHlFQUF5RTtRQUd6RSxJQUFJLENBQUNELEdBQUcsQ0FBQzFGLElBQUksR0FBRzNDO1FBRWhCLElBQUkyQyxPQUFPLElBQUksQ0FBQzRGLE9BQU8sRUFBRTtZQUN2Qix3Q0FBd0M7WUFDeEN0SSxRQUFRdUIsUUFBUSxHQUFHLE1BQU1nQixPQUFPLElBQUksQ0FBQytGLE9BQU8sQ0FBQzVGLElBQUk7UUFDbkQ7UUFFQSxJQUFJdkMsT0FBT0wsV0FBVzRDLEtBQUszQyxNQUFNQztRQUNqQyxJQUFJLENBQUNHLE1BQU0sT0FBTztRQUNsQixJQUFJLENBQUNzSSxRQUFRLENBQUN0STtRQUNkLElBQUlrQixRQUFRckIsUUFBUXFCLEtBQUssS0FBSzZCLFlBQVksSUFBSSxDQUFDN0IsS0FBSyxDQUFDVixNQUFNLEdBQUdYLFFBQVFxQixLQUFLO1FBQzNFLElBQUksQ0FBQ0EsS0FBSyxDQUFDcUgsTUFBTSxDQUFDckgsT0FBTyxHQUFHbEI7UUFDNUIsT0FBT0E7SUFDVCxFQUNBOzs7O0dBSUM7SUFHRDZDLE9BQU9SLE9BQU8sR0FBRyxTQUFTQSxRQUFRM0MsSUFBSSxFQUFFRSxJQUFJLEVBQUV3SSxXQUFXO1FBQ3ZELElBQUlJLFVBQVUsSUFBSSxDQUFDMUQsR0FBRyxDQUFDcEY7UUFDdkIsSUFBSStJLFdBQVcsSUFBSSxDQUFDdkgsS0FBSyxDQUFDNEUsT0FBTyxDQUFDMEM7UUFFbEMsSUFBSUEsU0FBUztZQUNYLElBQUksQ0FBQ2xGLE1BQU0sQ0FBQ2tGO1FBQ2Q7UUFFQSxJQUFJM0ksVUFBVXVJO1FBQ2QsSUFBSUssYUFBYSxDQUFDLEdBQUc1SSxVQUFVbEIsOEVBQVFBLENBQUMsQ0FBQyxHQUFHeUosYUFBYTtZQUN2RGxILE9BQU91SDtRQUNUO1FBQ0EsT0FBTyxJQUFJLENBQUM3QyxHQUFHLENBQUNsRyxNQUFNRSxNQUFNQztJQUM5QixFQUNBOztHQUVDO0lBR0RnRCxPQUFPaUMsR0FBRyxHQUFHLFNBQVNBLElBQUk0RCxjQUFjO1FBQ3RDLE9BQU8sSUFBSSxDQUFDbEosR0FBRyxDQUFDa0osZUFBZTtJQUNqQyxFQUNBOztHQUVDO0lBR0Q3RixPQUFPUyxNQUFNLEdBQUcsU0FBU0EsT0FBT3RELElBQUk7UUFDbEMsSUFBSSxDQUFDMkksVUFBVSxDQUFDM0k7UUFDaEIsT0FBTyxJQUFJLENBQUNpSSxHQUFHLENBQUNqSSxLQUFLdUMsR0FBRyxDQUFDO1FBQ3pCLElBQUksQ0FBQ3JCLEtBQUssQ0FBQ3FILE1BQU0sQ0FBQyxJQUFJLENBQUNySCxLQUFLLENBQUM0RSxPQUFPLENBQUM5RixPQUFPO0lBQzlDLEVBQ0E7O0dBRUM7SUFHRDZDLE9BQU9pRCxPQUFPLEdBQUcsU0FBU0EsUUFBUTlGLElBQUk7UUFDcEMsT0FBTyxJQUFJLENBQUNrQixLQUFLLENBQUM0RSxPQUFPLENBQUM5RjtJQUM1QixFQUNBOztHQUVDO0lBR0Q2QyxPQUFPSyxPQUFPLEdBQUcsU0FBU0E7UUFDeEIsSUFBSWpELFVBQVUsSUFBSSxDQUFDSixPQUFPLENBQUNDLEdBQUcsQ0FBQ0csT0FBTyxFQUFFLHFGQUFxRjtRQUM3SCx1REFBdUQ7UUFFdkQsSUFBSSxDQUFDaUIsS0FBSyxDQUFDMEgsS0FBSyxDQUFDLEdBQUdDLE9BQU8sQ0FBQzVJLFFBQVErRixhQUFhLEVBQUUvRjtJQUNyRCxFQUNBOztHQUVDO0lBR0Q0QyxPQUFPeUYsUUFBUSxHQUFHLFNBQVNBLFNBQVN0SSxJQUFJO1FBQ3RDLElBQUksQ0FBQ1IsR0FBRyxDQUFDUSxLQUFLdUMsR0FBRyxDQUFDLEdBQUd2QztRQUVyQixJQUFJQSxnQkFBZ0IyRCxXQUFXO1lBQzdCLElBQUksQ0FBQ25FLEdBQUcsQ0FBQ1EsS0FBS29CLFFBQVEsQ0FBQyxHQUFHcEI7WUFDMUIsSUFBSUEsS0FBS2tFLEVBQUUsRUFBRSxJQUFJLENBQUNpRSxPQUFPLENBQUNuSSxLQUFLdUMsR0FBRyxDQUFDLEdBQUd2QyxLQUFLa0UsRUFBRTtRQUMvQyxPQUFPLElBQUlsRSxnQkFBZ0J1RyxpQkFBaUIsSUFBSSxDQUFDTyxTQUFTLEVBQUU7WUFDMUQsSUFBSSxDQUFDQSxTQUFTLENBQUM5RyxLQUFLTixJQUFJLENBQUMsR0FBR00sS0FBS2tFLEVBQUU7UUFDckM7SUFDRixFQUNBOztHQUVDO0lBR0RyQixPQUFPOEYsVUFBVSxHQUFHLFNBQVNBLFdBQVczSSxJQUFJO1FBQzFDLE9BQU8sSUFBSSxDQUFDUixHQUFHLENBQUNRLEtBQUt1QyxHQUFHLENBQUM7UUFFekIsSUFBSXZDLGdCQUFnQjJELFdBQVc7WUFDN0IsT0FBTyxJQUFJLENBQUNuRSxHQUFHLENBQUNRLEtBQUtvQixRQUFRLENBQUM7WUFDOUIsT0FBTyxJQUFJLENBQUMrRyxPQUFPLENBQUNuSSxLQUFLdUMsR0FBRyxDQUFDO1FBQy9CLE9BQU8sSUFBSXZDLGdCQUFnQnVHLGVBQWU7WUFDeEMsT0FBTyxJQUFJLENBQUNPLFNBQVMsQ0FBQzlHLEtBQUtOLElBQUksQ0FBQztRQUNsQztJQUNGLEVBQ0E7O0dBRUM7SUFHRG1ELE9BQU9pRyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsSUFBSXBKO1FBQ0osSUFBSXFKO1FBQ0osSUFBSWxKO1FBRUosSUFBSSxPQUFRd0gsQ0FBQUEsVUFBVTdHLE1BQU0sSUFBSSxJQUFJdUMsWUFBWXNFLFNBQVMsQ0FBQyxFQUFFLE1BQU0sVUFBVTtZQUMxRTNILE9BQU8ySCxVQUFVN0csTUFBTSxJQUFJLElBQUl1QyxZQUFZc0UsU0FBUyxDQUFDLEVBQUU7WUFDdkQwQixPQUFPMUIsVUFBVTdHLE1BQU0sSUFBSSxJQUFJdUMsWUFBWXNFLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZEeEgsVUFBVXdILFVBQVU3RyxNQUFNLElBQUksSUFBSXVDLFlBQVlzRSxTQUFTLENBQUMsRUFBRTtRQUM1RCxPQUFPO1lBQ0wwQixPQUFPMUIsVUFBVTdHLE1BQU0sSUFBSSxJQUFJdUMsWUFBWXNFLFNBQVMsQ0FBQyxFQUFFO1lBQ3ZEeEgsVUFBVXdILFVBQVU3RyxNQUFNLElBQUksSUFBSXVDLFlBQVlzRSxTQUFTLENBQUMsRUFBRTtZQUMxRDNILE9BQU87UUFDVDtRQUVBLElBQUlBLE1BQU07WUFDUixJQUFJLENBQUNzSixTQUFTLENBQUMsSUFBSSxDQUFDbEUsR0FBRyxDQUFDcEYsT0FBT3FKLE1BQU1sSjtRQUN2QyxPQUFPO1lBQ0wsSUFBSyxJQUFJcUIsUUFBUSxHQUFHQSxRQUFRLElBQUksQ0FBQ0EsS0FBSyxDQUFDVixNQUFNLEVBQUVVLFFBQVM7Z0JBQ3RELElBQUksQ0FBQzhILFNBQVMsQ0FBQyxJQUFJLENBQUM5SCxLQUFLLENBQUNBLE1BQU0sRUFBRTZILE1BQU1sSjtZQUMxQztRQUNGO0lBQ0YsRUFDQTs7R0FFQztJQUdEZ0QsT0FBT21HLFNBQVMsR0FBRyxTQUFTQSxVQUFVaEosSUFBSSxFQUFFK0ksSUFBSSxFQUFFbEosT0FBTztRQUN2RCxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUN0QkEsVUFBVWtJO1FBQ1o7UUFFQSxJQUFJa0IsaUJBQWlCLElBQUksQ0FBQ3BKLE9BQU8sRUFDN0JJLFVBQVVnSixlQUFlbkosR0FBRyxDQUFDRyxPQUFPLEVBQ3BDeUMsUUFBUXVHLGVBQWV2RyxLQUFLLEVBQUUseURBQXlEO1FBRTNGLElBQUkxQyxLQUFLMEYsS0FBSyxZQUFZQyxVQUFVO1lBQ2xDM0YsS0FBSzBGLEtBQUssQ0FBQ29ELE1BQU0sQ0FBQ0MsTUFBTWxKO1lBQ3hCO1FBQ0Y7UUFFQSxJQUFJUixRQUFRVyxLQUFLWCxLQUFLO1FBQ3RCWSxRQUFRaUosUUFBUSxDQUFDSCxNQUFNL0ksTUFBTTBDLE9BQU83QyxVQUFVLDRFQUE0RTtRQUUxSCxJQUFJQSxRQUFRcUQsT0FBTyxJQUFJN0QsU0FBU0EsVUFBVVcsS0FBS1gsS0FBSyxFQUFFO1lBQ3BELDJFQUEyRTtZQUMzRVksUUFBUWlILGNBQWMsQ0FBQ2xILEtBQUtYLEtBQUssRUFBRVcsTUFBTTBDLFFBQVEsd0JBQXdCO1lBRXpFLElBQUssSUFBSWYsUUFBUTNCLEtBQUtYLEtBQUssQ0FBRTtnQkFDM0IsSUFBSThKLFlBQVluSixLQUFLWCxLQUFLLENBQUNzQyxLQUFLO2dCQUNoQyxJQUFJeUgsWUFBWS9KLEtBQUssQ0FBQ3NDLEtBQUssRUFBRSw0SUFBNEk7Z0JBQ3pLLDBHQUEwRztnQkFFMUcsSUFBSXdILGNBQWNDLFdBQVc7b0JBQzNCcEosS0FBSzJCLElBQUksQ0FBQ0EsTUFBTXdILFdBQVduQjtnQkFDN0I7WUFDRixFQUFFLGdCQUFnQjtZQUdsQixJQUFLLElBQUlwRyxTQUFTdkMsTUFBTztnQkFDdkIsSUFBSWdLLGFBQWFySixLQUFLWCxLQUFLLENBQUN1QyxNQUFNO2dCQUNsQyxJQUFJMEgsYUFBYWpLLEtBQUssQ0FBQ3VDLE1BQU0sRUFBRSw0SUFBNEk7Z0JBQzNLLDBHQUEwRztnQkFFMUcsSUFBSXlILGNBQWMsUUFBUUEsZUFBZUMsWUFBWTtvQkFDbkR0SixLQUFLMkIsSUFBSSxDQUFDQyxPQUFPLE1BQU1vRztnQkFDekI7WUFDRjtRQUNGO0lBQ0YsRUFDQTs7R0FFQztJQUdEbkYsT0FBTzBCLFFBQVEsR0FBRyxTQUFTQSxTQUFTMUUsT0FBTztRQUN6QyxJQUFJbUIsTUFBTTtRQUNWLElBQUkwQixRQUFRLElBQUksQ0FBQzdDLE9BQU8sQ0FBQzZDLEtBQUs7UUFDOUIsSUFBSThCLE9BQU85QixRQUFRQSxNQUFNN0MsT0FBTyxDQUFDMkUsSUFBSSxHQUFHO1FBRXhDLElBQUkvQyx3QkFBd0JkLHFCQUFxQmQsVUFDN0NnQixZQUFZWSxzQkFBc0JaLFNBQVM7UUFFL0MsSUFBSyxJQUFJSyxRQUFRLEdBQUdBLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUNWLE1BQU0sRUFBRVUsUUFBUztZQUN0RCxJQUFJbEIsT0FBTyxJQUFJLENBQUNrQixLQUFLLENBQUNBLE1BQU07WUFDNUIsSUFBSXFJLE1BQU12SixLQUFLdUUsUUFBUSxDQUFDMUUsVUFBVSxtQ0FBbUM7WUFFckUsSUFBSSxDQUFDMEosT0FBTyxDQUFDL0UsTUFBTTtZQUNuQixJQUFJeEQsS0FBS0EsT0FBT0g7WUFDaEJHLE9BQU91STtRQUNUO1FBRUEsT0FBT3ZJO0lBQ1Q7SUFFQSxPQUFPMkU7QUFDVDtBQUVBLElBQUk2RCxhQUNKLFdBQVcsR0FDWDtJQUNFLFNBQVNBLFdBQVduRSxNQUFNLEVBQUV4RixPQUFPO1FBQ2pDLElBQUksQ0FBQzZELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUMrRixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDdEIsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxDQUFDckIsU0FBUyxHQUFHLENBQUM7UUFDbEIsSUFBSSxDQUFDakgsT0FBTyxHQUFHbEIsOEVBQVFBLENBQUMsQ0FBQyxHQUFHa0IsU0FBUztZQUNuQzZDLE9BQU8sSUFBSTtZQUNYc0MsUUFBUSxJQUFJO1lBQ1ptRCxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQnJCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1FBQzNCO1FBRUEsSUFBSWpILFFBQVE4QyxRQUFRLEVBQUU7WUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSS9DLFFBQVE4QyxRQUFRLENBQUMsSUFBSTtRQUMzQztRQUVBLElBQUksQ0FBQytDLEtBQUssR0FBRyxJQUFJQyxTQUFTLElBQUksQ0FBQzlGLE9BQU87UUFFdEMsSUFBSyxJQUFJSCxRQUFRMkYsT0FBUTtZQUN2QixJQUFJLENBQUNLLEtBQUssQ0FBQ0UsR0FBRyxDQUFDbEcsTUFBTTJGLE1BQU0sQ0FBQzNGLEtBQUs7UUFDbkM7UUFFQSxJQUFJLENBQUNnRyxLQUFLLENBQUN4QyxPQUFPO0lBQ3BCO0lBQ0E7O0dBRUMsR0FHRCxJQUFJTCxTQUFTMkcsV0FBVzFHLFNBQVM7SUFFakNELE9BQU82RyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsSUFBSSxJQUFJLENBQUNoRyxRQUFRLEVBQUUsT0FBTyxJQUFJO1FBQzlCLElBQUksSUFBSSxDQUFDZCxRQUFRLEVBQUUsSUFBSSxDQUFDQSxRQUFRLENBQUM4RyxNQUFNO1FBQ3ZDLElBQUksQ0FBQ2hHLFFBQVEsR0FBRyxNQUFNLDRGQUE0RjtRQUVsSCxJQUFJLENBQUMsSUFBSSxDQUFDK0YsUUFBUSxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUMvQixPQUFPLElBQUk7SUFDYixFQUNBOztHQUVDO0lBR0Q5RyxPQUFPK0csTUFBTSxHQUFHLFNBQVNBO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNsRyxRQUFRLEVBQUUsT0FBTyxJQUFJO1FBQy9CLElBQUksSUFBSSxDQUFDZCxRQUFRLEVBQUUsSUFBSSxDQUFDQSxRQUFRLENBQUNnSCxNQUFNO1FBQ3ZDLElBQUksQ0FBQ2xHLFFBQVEsR0FBRztRQUNoQixPQUFPLElBQUk7SUFDYixFQUNBOzs7R0FHQztJQUdEYixPQUFPa0QsT0FBTyxHQUFHLFNBQVNBLFFBQVFyRyxJQUFJLEVBQUVFLElBQUksRUFBRUMsT0FBTztRQUNuRCxJQUFJZ0ssUUFBUSxJQUFJLENBQUNBLEtBQUssRUFBRSw0QkFBNEI7UUFDcEQsK0VBQStFO1FBQy9FLG1EQUFtRDtRQUVuRCxJQUFJLElBQUksQ0FBQ25HLFFBQVEsSUFBSSxDQUFDbUcsT0FBTyxJQUFJLENBQUNBLEtBQUssR0FBRyxFQUFFO1FBQzVDLElBQUk3SixPQUFPLElBQUksQ0FBQzBGLEtBQUssQ0FBQ0UsR0FBRyxDQUFDbEcsTUFBTUUsTUFBTUM7UUFDdEMsSUFBSSxDQUFDRyxNQUFNLE9BQU87UUFDbEIsSUFBSSxDQUFDSCxPQUFPLENBQUNDLEdBQUcsQ0FBQ0csT0FBTyxDQUFDK0YsYUFBYSxDQUFDaEc7UUFFdkMsSUFBSSxJQUFJLENBQUMwRCxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQytGLFFBQVEsRUFBRSxPQUFPekosTUFBTSxxRUFBcUU7WUFDdEcsMkRBQTJEO1lBRTNELElBQUk2SixPQUFPQSxNQUFNQyxJQUFJLENBQUM5SjtpQkFBVztnQkFDL0IsSUFBSSxDQUFDK0osVUFBVSxDQUFDL0o7Z0JBRWhCLElBQUksSUFBSSxDQUFDNkosS0FBSyxFQUFFO29CQUNkLElBQUksQ0FBQ0EsS0FBSyxDQUFDaEIsT0FBTyxDQUFDLElBQUksQ0FBQ2tCLFVBQVUsRUFBRSxJQUFJO29CQUN4QyxJQUFJLENBQUNGLEtBQUssR0FBRzlHO2dCQUNmO1lBQ0Y7WUFDQSxPQUFPL0M7UUFDVCxFQUFFLCtDQUErQztRQUNqRCx1REFBdUQ7UUFHdkQsSUFBSSxDQUFDeUosUUFBUSxHQUFHO1FBQ2hCLE9BQU96SjtJQUNULEVBQ0E7O0dBRUM7SUFHRDZDLE9BQU9nQyxXQUFXLEdBQUcsU0FBU0EsWUFBWTZELGNBQWMsRUFBRTlJLElBQUksRUFBRUMsT0FBTztRQUNyRSxJQUFJMkksVUFBVSxJQUFJLENBQUM5QyxLQUFLLENBQUNaLEdBQUcsQ0FBQzREO1FBQzdCLElBQUksQ0FBQ0YsU0FBUyxPQUFPLElBQUksQ0FBQ3pDLE9BQU8sQ0FBQzJDLGdCQUFnQjlJLE1BQU1DO1FBQ3hELElBQUlvRyxVQUFVLElBQUksQ0FBQ1AsS0FBSyxDQUFDckQsT0FBTyxDQUFDcUcsZ0JBQWdCOUksTUFBTUM7UUFFdkQsSUFBSW9HLFNBQVM7WUFDWCxJQUFJLENBQUNwRyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0csT0FBTyxDQUFDK0YsYUFBYSxDQUFDQztRQUN6QztRQUVBLElBQUksSUFBSSxDQUFDdkMsUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMrRixRQUFRLEVBQUUsT0FBT3hELFNBQVMsK0VBQStFO1lBQ25ILDJEQUEyRDtZQUUzRCxJQUFJLElBQUksQ0FBQ3JELFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDcUQsU0FBUztvQkFDWixJQUFJLENBQUNyRCxRQUFRLENBQUNvSCxVQUFVLENBQUN4QjtnQkFDM0IsT0FBTyxJQUFJQSxRQUFRakYsVUFBVSxFQUFFO29CQUM3QixJQUFJLENBQUNYLFFBQVEsQ0FBQ2lDLFdBQVcsQ0FBQzJELFFBQVFqRixVQUFVLEVBQUUwQztnQkFDaEQ7WUFDRjtZQUVBLE9BQU9BO1FBQ1QsRUFBRSxtREFBbUQ7UUFDckQsdURBQXVEO1FBR3ZELElBQUksQ0FBQ3dELFFBQVEsR0FBRztRQUNoQixPQUFPeEQ7SUFDVCxFQUNBOztHQUVDO0lBR0RwRCxPQUFPa0gsVUFBVSxHQUFHLFNBQVNBLFdBQVcvSixJQUFJO1FBQzFDLElBQUksSUFBSSxDQUFDNEMsUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQ0EsUUFBUSxDQUFDbUgsVUFBVSxDQUFDL0o7UUFDM0I7SUFDRixFQUNBOzs7R0FHQztJQUdENkMsT0FBT29ILFFBQVEsR0FBRyxTQUFTQSxTQUFTNUUsTUFBTSxFQUFFeEYsT0FBTztRQUNqRCxJQUFJcUssUUFBUSxFQUFFO1FBRWQsSUFBSyxJQUFJeEssUUFBUTJGLE9BQVE7WUFDdkIsSUFBSXJGLE9BQU8sSUFBSSxDQUFDK0YsT0FBTyxDQUFDckcsTUFBTTJGLE1BQU0sQ0FBQzNGLEtBQUssRUFBRUc7WUFDNUMsSUFBSUcsTUFBTWtLLE1BQU1KLElBQUksQ0FBQzlKO1FBQ3ZCO1FBRUEsT0FBT2tLO0lBQ1QsRUFDQTs7R0FFQztJQUdEckgsT0FBT2dELE9BQU8sR0FBRyxTQUFTQSxRQUFRNkMsY0FBYztRQUM5QyxPQUFPLElBQUksQ0FBQ2hELEtBQUssQ0FBQ1osR0FBRyxDQUFDNEQ7SUFDeEIsRUFDQTs7O0dBR0M7SUFHRDdGLE9BQU9tSCxVQUFVLEdBQUcsU0FBU0EsV0FBV3RLLElBQUk7UUFDMUMsSUFBSU0sT0FBTyxPQUFPTixTQUFTLFdBQVdBLE9BQU8sSUFBSSxDQUFDZ0csS0FBSyxDQUFDWixHQUFHLENBQUNwRjtRQUU1RCxJQUFJLENBQUNNLFFBQVEsMkVBQTJFO1FBQ3hGLHFEQUFxRDtRQUNyRCxJQUFJLENBQUMwRCxRQUFRLElBQUksQ0FBQzFELEtBQUt1RCxVQUFVLEVBQUU7WUFDakMsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDbUMsS0FBSyxDQUFDcEMsTUFBTSxDQUFDdEQ7UUFFbEIsSUFBSSxJQUFJLENBQUMwRCxRQUFRLElBQUkxRCxLQUFLdUQsVUFBVSxJQUFJLElBQUksQ0FBQ1gsUUFBUSxFQUFFO1lBQ3JELE9BQU8sSUFBSSxDQUFDQSxRQUFRLENBQUNvSCxVQUFVLENBQUNoSyxLQUFLdUQsVUFBVTtRQUNqRDtRQUVBLE9BQU87SUFDVCxFQUNBOztHQUVDO0lBR0RWLE9BQU9pRCxPQUFPLEdBQUcsU0FBU0EsUUFBUTlGLElBQUk7UUFDcEMsT0FBTyxJQUFJLENBQUMwRixLQUFLLENBQUNJLE9BQU8sQ0FBQzlGO0lBQzVCLEVBQ0E7O0dBRUM7SUFHRDZDLE9BQU84RyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsSUFBSSxJQUFJLENBQUMvRyxRQUFRLEVBQUUsSUFBSSxDQUFDQSxRQUFRLENBQUMrRyxNQUFNO1FBQ3ZDLElBQUksQ0FBQ0YsUUFBUSxHQUFHO1FBQ2hCLE9BQU8sSUFBSTtJQUNiLEVBQ0E7O0dBRUM7SUFHRDVHLE9BQU9pRyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsSUFBSXFCO1FBRUhBLENBQUFBLGNBQWMsSUFBSSxDQUFDekUsS0FBSyxFQUFFb0QsTUFBTSxDQUFDMUIsS0FBSyxDQUFDK0MsYUFBYTlDO1FBRXJELE9BQU8sSUFBSTtJQUNiLEVBQ0E7O0dBRUM7SUFHRHhFLE9BQU9tRyxTQUFTLEdBQUcsU0FBU0EsVUFBVWhKLElBQUksRUFBRStJLElBQUksRUFBRWxKLE9BQU87UUFDdkQsSUFBSSxDQUFDNkYsS0FBSyxDQUFDc0QsU0FBUyxDQUFDaEosTUFBTStJLE1BQU1sSjtRQUNqQyxPQUFPLElBQUk7SUFDYixFQUNBOztHQUVDO0lBR0RnRCxPQUFPMEIsUUFBUSxHQUFHLFNBQVNBLFNBQVMxRSxPQUFPO1FBQ3pDLE9BQU8sSUFBSSxDQUFDNkYsS0FBSyxDQUFDbkIsUUFBUSxDQUFDMUU7SUFDN0I7SUFFQSxPQUFPMko7QUFDVDtBQUVBLElBQUlZLGtCQUNKLFdBQVcsR0FDWDtJQUNFLFNBQVNBO1FBQ1AsSUFBSSxDQUFDbkssT0FBTyxHQUFHO1lBQ2JvSyxVQUFVLEVBQUU7WUFDWkMsVUFBVSxFQUFFO1FBQ2Q7UUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO0lBQ25CO0lBRUEsSUFBSTFILFNBQVN1SCxnQkFBZ0J0SCxTQUFTO0lBRXRDOztHQUVDLEdBQ0RELE9BQU8zQyxZQUFZLEdBQUcsU0FBU0EsYUFBYVIsSUFBSSxFQUFFRSxJQUFJLEVBQUVDLE9BQU87UUFDN0QsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDZ0ssUUFBUSxDQUFDckssWUFBWSxDQUFDTSxNQUFNLEVBQUVELElBQUs7WUFDMUQsSUFBSVAsT0FBTyxJQUFJLENBQUN1SyxRQUFRLENBQUNySyxZQUFZLENBQUNLLEVBQUUsQ0FBQ2IsTUFBTUUsTUFBTUM7WUFDckQsSUFBSUcsTUFBTSxPQUFPQTtRQUNuQjtRQUVBLE9BQU87SUFDVCxFQUNBOztHQUVDO0lBR0Q2QyxPQUFPbUQsYUFBYSxHQUFHLFNBQVNBLGNBQWNoRyxJQUFJO1FBQ2hELElBQUlBLEtBQUt5QyxXQUFXLEVBQUU7UUFDdEIsSUFBSUMsUUFBUTFDLEtBQUtILE9BQU8sQ0FBQzZDLEtBQUs7UUFFOUIsSUFBSyxJQUFJbkMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2dLLFFBQVEsQ0FBQ3ZFLGFBQWEsQ0FBQ3hGLE1BQU0sRUFBRUQsSUFBSztZQUMzRCxJQUFJLENBQUNnSyxRQUFRLENBQUN2RSxhQUFhLENBQUN6RixFQUFFLENBQUNQLE1BQU0wQztRQUN2QztRQUVBLElBQUkxQyxLQUFLWCxLQUFLLEVBQUUsSUFBSSxDQUFDNkgsY0FBYyxDQUFDbEgsS0FBS1gsS0FBSyxFQUFFVyxNQUFNMEM7UUFDdEQxQyxLQUFLeUMsV0FBVyxHQUFHO0lBQ3JCLEVBQ0E7O0dBRUM7SUFHREksT0FBT3FFLGNBQWMsR0FBRyxTQUFTQSxlQUFlN0gsS0FBSyxFQUFFVyxJQUFJLEVBQUUwQyxLQUFLO1FBQ2hFLElBQUssSUFBSW5DLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNnSyxRQUFRLENBQUNyRCxjQUFjLENBQUMxRyxNQUFNLEVBQUVELElBQUs7WUFDNURQLEtBQUtYLEtBQUssR0FBRyxJQUFJLENBQUNrTCxRQUFRLENBQUNyRCxjQUFjLENBQUMzRyxFQUFFLENBQUNQLEtBQUtYLEtBQUssRUFBRVcsTUFBTTBDO1FBQ2pFO0lBQ0YsRUFDQTs7R0FFQztJQUdERyxPQUFPMkgsY0FBYyxHQUFHLFNBQVNBLGVBQWU5SCxLQUFLO1FBQ25ELElBQUssSUFBSW5DLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNnSyxRQUFRLENBQUNDLGNBQWMsQ0FBQ2hLLE1BQU0sRUFBRUQsSUFBSztZQUM1RCxJQUFJLENBQUNnSyxRQUFRLENBQUNDLGNBQWMsQ0FBQ2pLLEVBQUUsQ0FBQ21DO1FBQ2xDO0lBQ0YsRUFDQTs7R0FFQztJQUdERyxPQUFPcUcsUUFBUSxHQUFHLFNBQVNBLFNBQVNILElBQUksRUFBRS9JLElBQUksRUFBRTBDLEtBQUssRUFBRTdDLE9BQU87UUFDNUQsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDZ0ssUUFBUSxDQUFDckIsUUFBUSxDQUFDMUksTUFBTSxFQUFFRCxJQUFLO1lBQ3RELElBQUksQ0FBQ2dLLFFBQVEsQ0FBQ3JCLFFBQVEsQ0FBQzNJLEVBQUUsQ0FBQ3dJLE1BQU0vSSxNQUFNMEMsT0FBTzdDO1FBQy9DO0lBQ0YsRUFDQTs7R0FFQztJQUdEZ0QsT0FBT00sYUFBYSxHQUFHLFNBQVNBLGNBQWMvQyxLQUFLLEVBQUV1QixJQUFJLEVBQUUzQixJQUFJO1FBQzdELElBQUl5SyxpQkFBaUJySztRQUVyQixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNnSyxRQUFRLENBQUNwSCxhQUFhLENBQUMzQyxNQUFNLEVBQUVELElBQUs7WUFDM0RrSyxpQkFBaUIsSUFBSSxDQUFDRixRQUFRLENBQUNwSCxhQUFhLENBQUM1QyxFQUFFLENBQUNrSyxnQkFBZ0I5SSxNQUFNM0I7UUFDeEU7UUFFQSxPQUFPeUs7SUFDVCxFQUNBOztHQUVDO0lBR0Q1SCxPQUFPNkgsR0FBRyxHQUFHLFNBQVNBLElBQUlDLFNBQVMsRUFBRTlLLE9BQU87UUFDMUMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFDdEJBLFVBQVU7Z0JBQ1JnSyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLElBQUk1SixVQUFVLElBQUksQ0FBQ0EsT0FBTyxDQUFDSixRQUFRZ0ssS0FBSyxDQUFDLEVBQUUsNERBQTREO1FBRXZHLElBQUk1SixRQUFRNkYsT0FBTyxDQUFDNkUsZUFBZSxDQUFDLEdBQUc7WUFDckM7UUFDRjtRQUVBMUssUUFBUTZKLElBQUksQ0FBQ2E7UUFDYixJQUFJLENBQUNKLFFBQVEsR0FBRyxFQUFFLENBQUNLLE1BQU0sQ0FBQyxJQUFJLENBQUMzSyxPQUFPLENBQUNxSyxRQUFRLEVBQUUsSUFBSSxDQUFDckssT0FBTyxDQUFDb0ssUUFBUSxFQUFFUSxNQUFNLENBQUMsU0FBVU4sUUFBUSxFQUFFTyxNQUFNO1lBQ3ZHLElBQUssSUFBSXBMLFFBQVFvTCxPQUFRO2dCQUN2QixJQUFJcEwsUUFBUTZLLFVBQVU7b0JBQ3BCQSxRQUFRLENBQUM3SyxLQUFLLENBQUNvSyxJQUFJLENBQUNnQixNQUFNLENBQUNwTCxLQUFLO2dCQUNsQyxPQUFPO29CQTUxQ2YsS0E2MUMrQyxHQUFHYix3REFBT0EsQ0FBQyxPQUFPLHlCQUEwQmEsT0FBTyxRQUFTLENBQU07Z0JBQ3pHO1lBQ0Y7WUFFQSxPQUFPNks7UUFDVCxHQUFHO1lBQ0RySyxjQUFjLEVBQUU7WUFDaEI4RixlQUFlLEVBQUU7WUFDakJrQixnQkFBZ0IsRUFBRTtZQUNsQnNELGdCQUFnQixFQUFFO1lBQ2xCckgsZUFBZSxFQUFFO1lBQ2pCK0YsVUFBVSxFQUFFO1FBQ2Q7SUFDRjtJQUVBLE9BQU9rQjtBQUNUO0FBRUE7O0NBRUMsR0FFRCxJQUFJVyxpQkFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQTtRQUNQLElBQUksQ0FBQ1IsUUFBUSxHQUFHLEVBQUU7SUFDcEI7SUFFQSxJQUFJMUgsU0FBU2tJLGVBQWVqSSxTQUFTO0lBRXJDOztHQUVDLEdBQ0RELE9BQU8rQyxHQUFHLEdBQUcsU0FBU0EsSUFBSWxELEtBQUs7UUFDN0IsSUFBSTZILFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzVCLElBQUlySixRQUFRd0IsTUFBTTdDLE9BQU8sQ0FBQ3FCLEtBQUs7UUFDL0IsSUFBSXFKLFNBQVN6RSxPQUFPLENBQUNwRCxXQUFXLENBQUMsR0FBRztRQUVwQyxJQUFJNkgsU0FBUy9KLE1BQU0sS0FBSyxLQUFLVSxTQUFTLElBQUksQ0FBQ0EsS0FBSyxFQUFFO1lBQ2hEcUosU0FBU1QsSUFBSSxDQUFDcEg7WUFDZDtRQUNGLEVBQUUsbUJBQW1CO1FBR3JCLElBQUssSUFBSW5DLElBQUksR0FBR0EsSUFBSWdLLFNBQVMvSixNQUFNLEVBQUVELElBQUs7WUFDeEMsSUFBSWdLLFFBQVEsQ0FBQ2hLLEVBQUUsQ0FBQ1YsT0FBTyxDQUFDcUIsS0FBSyxHQUFHQSxPQUFPO2dCQUNyQ3FKLFNBQVNoQyxNQUFNLENBQUNoSSxHQUFHLEdBQUdtQztnQkFDdEI7WUFDRjtRQUNGO0lBQ0YsRUFDQTs7R0FFQztJQUdERyxPQUFPbUksS0FBSyxHQUFHLFNBQVNBO1FBQ3RCLElBQUksQ0FBQ1QsUUFBUSxHQUFHLEVBQUU7SUFDcEIsRUFDQTs7R0FFQztJQUdEMUgsT0FBT1MsTUFBTSxHQUFHLFNBQVNBLE9BQU9aLEtBQUs7UUFDbkMsSUFBSXhCLFFBQVEsSUFBSSxDQUFDcUosUUFBUSxDQUFDekUsT0FBTyxDQUFDcEQ7UUFDbEMsSUFBSSxDQUFDNkgsUUFBUSxDQUFDaEMsTUFBTSxDQUFDckgsT0FBTztJQUM5QixFQUNBOztHQUVDO0lBR0QyQixPQUFPMEIsUUFBUSxHQUFHLFNBQVNBLFNBQVMwRyxLQUFLO1FBQ3ZDLElBQUlDLE9BQU9ELFVBQVUsS0FBSyxJQUFJLENBQUMsSUFBSUEsT0FDL0J2SCxXQUFXd0gsS0FBS3hILFFBQVEsRUFDeEI3RCxVQUFVWixtR0FBNkJBLENBQUNpTSxNQUFNO1lBQUM7U0FBVztRQUU5RCxJQUFJekosd0JBQXdCZCxxQkFBcUJkLFVBQzdDZ0IsWUFBWVksc0JBQXNCWixTQUFTO1FBRS9DLElBQUkwSSxNQUFNO1FBRVYsSUFBSyxJQUFJaEosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2dLLFFBQVEsQ0FBQy9KLE1BQU0sRUFBRUQsSUFBSztZQUM3QyxJQUFJbUMsUUFBUSxJQUFJLENBQUM2SCxRQUFRLENBQUNoSyxFQUFFO1lBRTVCLElBQUltRCxZQUFZLFFBQVFoQixNQUFNZ0IsUUFBUSxLQUFLQSxVQUFVO2dCQUNuRDtZQUNGO1lBRUEsSUFBSTZGLEtBQUtBLE9BQU8xSTtZQUNoQjBJLE9BQU83RyxNQUFNNkIsUUFBUSxDQUFDMUU7UUFDeEI7UUFFQSxPQUFPMEo7SUFDVDtJQUVBekssa0ZBQVlBLENBQUNpTSxnQkFBZ0I7UUFBQztZQUM1QnhJLEtBQUs7WUFFTDs7S0FFQyxHQUNEdUMsS0FBSyxTQUFTQTtnQkFDWixPQUFPLElBQUksQ0FBQ3lGLFFBQVEsQ0FBQy9KLE1BQU0sS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDK0osUUFBUSxDQUFDLElBQUksQ0FBQ0EsUUFBUSxDQUFDL0osTUFBTSxHQUFHLEVBQUUsQ0FBQ1gsT0FBTyxDQUFDcUIsS0FBSztZQUMvRjtRQUNGO0tBQUU7SUFFRixPQUFPNko7QUFDVDtBQUVBOzs7OztDQUtDLEdBRUQsSUFBSUksU0FBUyxJQUFJSjtBQUVqQixrQkFBa0IsR0FFbEI7Ozs7Ozs7OztDQVNDLEdBQ0QsSUFBSUssZUFBZSxPQUFPQyxlQUFlLGNBQWNBLGFBQWEsTUFBcURFLEdBQUdELENBQU1BLEdBQUcsT0FBT0UsU0FBUyxlQUFlQSxLQUFLRCxJQUFJLEtBQUtBLE9BQU9DLE9BQU9DLFNBQVM7QUFFek0sSUFBSUMsS0FBSztBQUNULElBQUlOLFlBQVksQ0FBQ00sR0FBRyxJQUFJLE1BQU1OLFlBQVksQ0FBQ00sR0FBRyxHQUFHLEdBQUcsa0ZBQWtGO0FBQ3RJLG1GQUFtRjtBQUNuRixtRkFBbUY7QUFDbkYsY0FBYztBQUVkLElBQUlDLFdBQVdQLFlBQVksQ0FBQ00sR0FBRztBQUUvQixJQUFJRSxXQUFXO0FBQ2Y7Ozs7Q0FJQyxHQUVELElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJoTSxPQUFPO0lBQ3RELElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUVBLElBQUlpTSxjQUFjO0lBRWxCLElBQUk5SCxhQUFhLFNBQVNBLFdBQVdoRSxJQUFJLEVBQUUwQyxLQUFLO1FBQzlDb0osZUFBZTtRQUVmLElBQUlBLGNBQWNGLFVBQVU7WUE3L0NoQyxLQTgvQzJDLEdBQUcvTSx3REFBT0EsQ0FBQyxPQUFPLDREQUE0RGlOLGNBQWMsT0FBTyxDQUFNO1FBQ2hKO1FBRUEsSUFBSUMsUUFBUTtRQUNaLElBQUlDLFNBQVM7UUFFYixJQUFJdEosT0FBTztZQUNULElBQUlBLE1BQU03QyxPQUFPLENBQUNvTSxlQUFlLEVBQUU7Z0JBQ2pDRCxTQUFTdEosTUFBTTdDLE9BQU8sQ0FBQ29NLGVBQWU7WUFDeEM7WUFFQSxJQUFJdkosTUFBTTdDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDb0UsRUFBRSxJQUFJLE1BQU07Z0JBQ2hDNkgsUUFBUUcsT0FBT3hKLE1BQU03QyxPQUFPLENBQUNDLEdBQUcsQ0FBQ29FLEVBQUU7WUFDckM7UUFDRjtRQUVBLElBQUlyRSxRQUFRc00sTUFBTSxFQUFFO1lBQ2xCLHNFQUFzRTtZQUN0RSxPQUFPLEtBQU1ILENBQUFBLFVBQVUsR0FBRSxJQUFLTCxXQUFXSSxRQUFRRDtRQUNuRDtRQUVBLE9BQU9FLFNBQVNoTSxLQUFLdUMsR0FBRyxHQUFHLE1BQU1vSixXQUFZSSxDQUFBQSxRQUFRLE1BQU1BLFFBQVEsRUFBQyxJQUFLLE1BQU1EO0lBQ2pGO0lBRUEsT0FBTzlIO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELElBQUlvSSxVQUFVLFNBQVNBLFFBQVFDLEVBQUU7SUFDL0IsSUFBSWpNO0lBQ0osT0FBTztRQUNMLElBQUksQ0FBQ0EsT0FBT0EsUUFBUWlNO1FBQ3BCLE9BQU9qTTtJQUNUO0FBQ0Y7QUFDQTs7Q0FFQyxHQUdELElBQUlrTSxtQkFBbUIsU0FBU0EsaUJBQWlCQyxPQUFPLEVBQUU1SyxJQUFJO0lBQzVELElBQUk7UUFDRixrQkFBa0I7UUFDbEIsSUFBSTRLLFFBQVFDLGlCQUFpQixFQUFFO1lBQzdCLE9BQU9ELFFBQVFDLGlCQUFpQixDQUFDMUgsR0FBRyxDQUFDbkQ7UUFDdkM7UUFFQSxPQUFPNEssUUFBUWxOLEtBQUssQ0FBQ2lOLGdCQUFnQixDQUFDM0s7SUFDeEMsRUFBRSxPQUFPOEssS0FBSztRQUNaLHVDQUF1QztRQUN2QyxPQUFPO0lBQ1Q7QUFDRjtBQUNBOztDQUVDLEdBR0QsSUFBSWhKLGNBQWMsU0FBU0EsWUFBWThJLE9BQU8sRUFBRTVLLElBQUksRUFBRXZCLEtBQUs7SUFDekQsSUFBSTtRQUNGLElBQUlNLFdBQVdOO1FBRWYsSUFBSWQsTUFBTUMsT0FBTyxDQUFDYSxRQUFRO1lBQ3hCTSxXQUFXRCxXQUFXTDtRQUN4QixFQUFFLGtCQUFrQjtRQUdwQixJQUFJbU0sUUFBUUMsaUJBQWlCLEVBQUU7WUFDN0JELFFBQVFDLGlCQUFpQixDQUFDOUgsR0FBRyxDQUFDL0MsTUFBTWpCO1FBQ3RDLE9BQU87WUFDTCxJQUFJZ00sdUJBQXVCaE0sV0FBV0EsU0FBU29GLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztZQUN4RSxJQUFJNkcsK0JBQStCRCx1QkFBdUIsQ0FBQyxJQUFJaE0sU0FBU2tNLE1BQU0sQ0FBQyxHQUFHRix1QkFBdUIsS0FBS2hNO1lBQzlHNkwsUUFBUWxOLEtBQUssQ0FBQ29FLFdBQVcsQ0FBQzlCLE1BQU1nTCw4QkFBOEJELHVCQUF1QixDQUFDLElBQUksY0FBYztRQUMxRztJQUNGLEVBQUUsT0FBT0QsS0FBSztRQUNaLHVDQUF1QztRQUN2QyxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7Q0FFQyxHQUdELElBQUlqSixpQkFBaUIsU0FBU0EsZUFBZStJLE9BQU8sRUFBRTVLLElBQUk7SUFDeEQsSUFBSTtRQUNGLGtCQUFrQjtRQUNsQixJQUFJNEssUUFBUUMsaUJBQWlCLEVBQUU7WUFDN0JELFFBQVFDLGlCQUFpQixDQUFDSyxNQUFNLENBQUNsTDtRQUNuQyxPQUFPO1lBQ0w0SyxRQUFRbE4sS0FBSyxDQUFDbUUsY0FBYyxDQUFDN0I7UUFDL0I7SUFDRixFQUFFLE9BQU84SyxLQUFLO1FBL2xEaEIsS0FnbUR5QyxHQUFHNU4sd0RBQU9BLENBQUMsT0FBTyx5QkFBMEI0TixJQUFJSyxPQUFPLEdBQUcsNkNBQStDbkwsT0FBTyxRQUFTLENBQU07SUFDdEs7QUFDRjtBQUNBOztDQUVDLEdBR0QsSUFBSWlELGNBQWMsU0FBU0EsWUFBWTJILE9BQU8sRUFBRXRJLFlBQVk7SUFDMURzSSxRQUFRdEksWUFBWSxHQUFHQSxjQUFjLDZDQUE2QztJQUNsRixrQ0FBa0M7SUFFbEMsT0FBT3NJLFFBQVF0SSxZQUFZLEtBQUtBO0FBQ2xDO0FBQ0E7OztDQUdDLEdBR0QsSUFBSThJLFVBQVVYLFFBQVE7SUFDcEIsT0FBT1ksU0FBU0MsYUFBYSxDQUFDO0FBQ2hDO0FBQ0E7O0NBRUMsR0FFRCxTQUFTQyxnQkFBZ0IzQyxRQUFRLEVBQUUxSyxPQUFPO0lBQ3hDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJZ0ssU0FBUy9KLE1BQU0sRUFBRUQsSUFBSztRQUN4QyxJQUFJbUMsUUFBUTZILFFBQVEsQ0FBQ2hLLEVBQUU7UUFFdkIsSUFBSW1DLE1BQU1nQixRQUFRLElBQUloQixNQUFNN0MsT0FBTyxDQUFDcUIsS0FBSyxHQUFHckIsUUFBUXFCLEtBQUssSUFBSXdCLE1BQU03QyxPQUFPLENBQUNzTixjQUFjLEtBQUt0TixRQUFRc04sY0FBYyxFQUFFO1lBQ3BILE9BQU96SztRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7Q0FFQyxHQUdELFNBQVMwSyxpQkFBaUI3QyxRQUFRLEVBQUUxSyxPQUFPO0lBQ3pDLElBQUssSUFBSVUsSUFBSWdLLFNBQVMvSixNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxJQUFLO1FBQzdDLElBQUltQyxRQUFRNkgsUUFBUSxDQUFDaEssRUFBRTtRQUV2QixJQUFJbUMsTUFBTWdCLFFBQVEsSUFBSWhCLE1BQU03QyxPQUFPLENBQUNzTixjQUFjLEtBQUt0TixRQUFRc04sY0FBYyxFQUFFO1lBQzdFLE9BQU96SztRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7Q0FFQyxHQUdELFNBQVMySyxnQkFBZ0JDLElBQUk7SUFDM0IsSUFBSUMsT0FBT1I7SUFFWCxJQUFLLElBQUl4TSxJQUFJLEdBQUdBLElBQUlnTixLQUFLQyxVQUFVLENBQUNoTixNQUFNLEVBQUVELElBQUs7UUFDL0MsSUFBSWtOLE9BQU9GLEtBQUtDLFVBQVUsQ0FBQ2pOLEVBQUU7UUFFN0IsSUFBSWtOLEtBQUtDLFFBQVEsS0FBSyxLQUFLRCxLQUFLRSxTQUFTLENBQUNDLElBQUksT0FBT04sTUFBTTtZQUN6RCxPQUFPRztRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFDQTs7Q0FFQyxHQUdELFNBQVNJLGFBQWFoTyxPQUFPO0lBQzNCLElBQUkwSyxXQUFXWSxPQUFPWixRQUFRO0lBRTlCLElBQUlBLFNBQVMvSixNQUFNLEdBQUcsR0FBRztRQUN2Qiw4Q0FBOEM7UUFDOUMsSUFBSWtDLFFBQVF3SyxnQkFBZ0IzQyxVQUFVMUs7UUFFdEMsSUFBSTZDLFNBQVNBLE1BQU1FLFFBQVEsRUFBRTtZQUMzQixPQUFPO2dCQUNMb0MsUUFBUXRDLE1BQU1FLFFBQVEsQ0FBQ2tMLE9BQU8sQ0FBQ0MsVUFBVTtnQkFDekNOLE1BQU0vSyxNQUFNRSxRQUFRLENBQUNrTCxPQUFPO1lBQzlCO1FBQ0YsRUFBRSw0Q0FBNEM7UUFHOUNwTCxRQUFRMEssaUJBQWlCN0MsVUFBVTFLO1FBRW5DLElBQUk2QyxTQUFTQSxNQUFNRSxRQUFRLEVBQUU7WUFDM0IsT0FBTztnQkFDTG9DLFFBQVF0QyxNQUFNRSxRQUFRLENBQUNrTCxPQUFPLENBQUNDLFVBQVU7Z0JBQ3pDTixNQUFNL0ssTUFBTUUsUUFBUSxDQUFDa0wsT0FBTyxDQUFDRSxXQUFXO1lBQzFDO1FBQ0Y7SUFDRixFQUFFLDBEQUEwRDtJQUc1RCxJQUFJYixpQkFBaUJ0TixRQUFRc04sY0FBYztJQUUzQyxJQUFJQSxrQkFBa0IsT0FBT0EsbUJBQW1CLFVBQVU7UUFDeEQsSUFBSWMsVUFBVVosZ0JBQWdCRjtRQUU5QixJQUFJYyxTQUFTO1lBQ1gsT0FBTztnQkFDTGpKLFFBQVFpSixRQUFRRixVQUFVO2dCQUMxQk4sTUFBTVEsUUFBUUQsV0FBVztZQUMzQjtRQUNGLEVBQUUsK0VBQStFO1FBQ2pGLHFDQUFxQztRQWx0RHpDLEtBcXREeUMsR0FBR25QLHdEQUFPQSxDQUFDLE9BQU8sNEJBQTZCc08saUJBQWlCLGtCQUFtQixDQUFNO0lBQ2hJO0lBRUEsT0FBTztBQUNUO0FBQ0E7O0NBRUMsR0FHRCxTQUFTZSxZQUFZN08sS0FBSyxFQUFFUSxPQUFPO0lBQ2pDLElBQUlzTixpQkFBaUJ0TixRQUFRc04sY0FBYztJQUMzQyxJQUFJZ0IsV0FBV04sYUFBYWhPO0lBRTVCLElBQUlzTyxhQUFhLFNBQVNBLFNBQVNuSixNQUFNLEVBQUU7UUFDekNtSixTQUFTbkosTUFBTSxDQUFDb0osWUFBWSxDQUFDL08sT0FBTzhPLFNBQVNWLElBQUk7UUFDakQ7SUFDRixFQUFFLHlDQUF5QztJQUczQyxJQUFJTixrQkFBa0IsT0FBT0EsZUFBZU8sUUFBUSxLQUFLLFVBQVU7UUFDakUsSUFBSVcsd0JBQXdCbEI7UUFDNUIsSUFBSVksYUFBYU0sc0JBQXNCTixVQUFVO1FBQ2pELElBQUlBLFlBQVlBLFdBQVdLLFlBQVksQ0FBQy9PLE9BQU9nUCxzQkFBc0JMLFdBQVc7YUFBTzlLLEtBQXFDLEdBQUdyRSx3REFBT0EsQ0FBQyxPQUFPLDhDQUE4QyxDQUFNO1FBQ2xNO0lBQ0Y7SUFFQWtPLFVBQVV1QixXQUFXLENBQUNqUDtBQUN4QjtBQUNBOztDQUVDLEdBR0QsSUFBSWtQLFdBQVduQyxRQUFRO0lBQ3JCLElBQUlxQixPQUFPVCxTQUFTQyxhQUFhLENBQUM7SUFDbEMsT0FBT1EsT0FBT0EsS0FBS2UsWUFBWSxDQUFDLGFBQWE7QUFDL0M7QUFFQSxJQUFJQyxjQUFjLFNBQVMxRSxXQUFXMkUsU0FBUyxFQUFFMU8sSUFBSSxFQUFFa0IsS0FBSztJQUMxRCxJQUFJO1FBQ0YsSUFBSSxnQkFBZ0J3TixXQUFXO1lBQzdCQSxVQUFVM0UsVUFBVSxDQUFDL0osTUFBTWtCO1FBQzdCLE9BQ0ssSUFBSSxnQkFBZ0J3TixXQUFXO1lBQ2hDQSxVQUFVQyxVQUFVLENBQUMzTztRQUN2QjtJQUNKLEVBQUUsT0FBT3lNLEtBQUs7UUFwd0RoQixLQXF3RHlDLEdBQUc1Tix3REFBT0EsQ0FBQyxPQUFPLFdBQVc0TixJQUFJSyxPQUFPLElBQUksQ0FBTTtRQUN2RixPQUFPO0lBQ1Q7SUFFQSxPQUFPNEIsVUFBVUUsUUFBUSxDQUFDMU4sTUFBTTtBQUNsQztBQUVBLElBQUkyTiw2QkFBNkIsU0FBU0EsMkJBQTJCSCxTQUFTLEVBQUV4TixLQUFLO0lBQ25GLElBQUk0TixXQUFXSixVQUFVRSxRQUFRLENBQUNwTyxNQUFNLEVBQUUsZ0VBQWdFO0lBRTFHLElBQUlVLFVBQVU2QixhQUFhN0IsUUFBUTROLFVBQVU7UUFDM0MsNkNBQTZDO1FBQzdDLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPNU47QUFDVDtBQUVBLElBQUk2TixjQUFjLFNBQVNBO0lBQ3pCLElBQUlDLEtBQUtoQyxTQUFTaUMsYUFBYSxDQUFDLFVBQVUsbUVBQW1FO0lBQzdHLDhDQUE4QztJQUM5QywrREFBK0Q7SUFFL0RELEdBQUdFLFdBQVcsR0FBRztJQUNqQixPQUFPRjtBQUNUO0FBRUEsSUFBSUcsY0FDSixXQUFXLEdBQ1g7SUFDRSx5REFBeUQ7SUFDekQsbURBQW1EO0lBQ25ELFNBQVNBLFlBQVl6TSxLQUFLO1FBQ3hCLElBQUksQ0FBQzRKLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUM3SSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0QsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNvQixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ3dLLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ1IsUUFBUSxHQUFHLEVBQUU7UUFDbEIsMkVBQTJFO1FBQzNFLElBQUlsTSxPQUFPeUksT0FBT3ZGLEdBQUcsQ0FBQ2xEO1FBQ3RCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtRQUViLElBQUl3SSxPQUFPLElBQUksQ0FBQ3hJLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQzdDLE9BQU8sR0FBRyxDQUFDLEdBQzFDd1AsUUFBUW5FLEtBQUttRSxLQUFLLEVBQ2xCQyxPQUFPcEUsS0FBS29FLElBQUksRUFDaEJ4QixVQUFVNUMsS0FBSzRDLE9BQU87UUFFMUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBLFdBQVdpQjtRQUMxQixJQUFJLENBQUNqQixPQUFPLENBQUN5QixZQUFZLENBQUMsWUFBWTtRQUN0QyxJQUFJRixPQUFPLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ3lCLFlBQVksQ0FBQyxTQUFTRjtRQUM5QyxJQUFJQyxNQUFNLElBQUksQ0FBQ3hCLE9BQU8sQ0FBQ3lCLFlBQVksQ0FBQyxhQUFhRDtRQUNqRCxJQUFJRSxRQUFRakI7UUFDWixJQUFJaUIsT0FBTyxJQUFJLENBQUMxQixPQUFPLENBQUN5QixZQUFZLENBQUMsU0FBU0M7SUFDaEQ7SUFDQTs7R0FFQyxHQUdELElBQUkzTSxTQUFTc00sWUFBWXJNLFNBQVM7SUFFbENELE9BQU82RyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIseUVBQXlFO1FBQ3pFLElBQUksSUFBSSxDQUFDb0UsT0FBTyxDQUFDQyxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUNyTCxLQUFLLEVBQUU7UUFDNUN3TCxZQUFZLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ3BMLEtBQUssQ0FBQzdDLE9BQU8sR0FBRyxrRkFBa0Y7UUFDakksK0RBQStEO1FBRS9ELElBQUk0SixXQUFXZ0csUUFBUSxJQUFJLENBQUMvTSxLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLLENBQUMrRyxRQUFRO1FBRXhELElBQUksSUFBSSxDQUFDMkYsZ0JBQWdCLElBQUkzRixVQUFVO1lBQ3JDLElBQUksQ0FBQzJGLGdCQUFnQixHQUFHO1lBQ3hCLElBQUksQ0FBQ3pGLE1BQU07UUFDYjtJQUNGLEVBQ0E7O0dBRUM7SUFHRDlHLE9BQU8rRyxNQUFNLEdBQUcsU0FBU0E7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQ2xILEtBQUssRUFBRTtRQUNqQixJQUFJcUwsYUFBYSxJQUFJLENBQUNELE9BQU8sQ0FBQ0MsVUFBVTtRQUN4QyxJQUFJQSxZQUFZQSxXQUFXMkIsV0FBVyxDQUFDLElBQUksQ0FBQzVCLE9BQU8sR0FBRywwR0FBMEc7UUFDaEssOERBQThEO1FBRTlELElBQUksSUFBSSxDQUFDcEwsS0FBSyxDQUFDN0MsT0FBTyxDQUFDMkUsSUFBSSxFQUFFO1lBQzNCLElBQUksQ0FBQ29LLFFBQVEsR0FBRyxFQUFFO1lBQ2xCLElBQUksQ0FBQ2QsT0FBTyxDQUFDb0IsV0FBVyxHQUFHO1FBQzdCO0lBQ0YsRUFDQTs7R0FFQztJQUdEck0sT0FBTzhHLE1BQU0sR0FBRyxTQUFTQTtRQUN2QixJQUFJakgsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsSUFBSSxDQUFDQSxPQUFPO1FBRVosSUFBSUEsTUFBTTdDLE9BQU8sQ0FBQzJFLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUNtTCxXQUFXLENBQUNqTixNQUFNZ0QsS0FBSztZQUM1QjtRQUNGO1FBRUEsSUFBSSxDQUFDb0ksT0FBTyxDQUFDb0IsV0FBVyxHQUFHLE9BQU94TSxNQUFNNkIsUUFBUSxLQUFLO0lBQ3ZELEVBQ0E7O0dBRUM7SUFHRDFCLE9BQU84TSxXQUFXLEdBQUcsU0FBU0EsWUFBWWpLLEtBQUssRUFBRWtLLFlBQVk7UUFDM0QsSUFBSyxJQUFJclAsSUFBSSxHQUFHQSxJQUFJbUYsTUFBTXhFLEtBQUssQ0FBQ1YsTUFBTSxFQUFFRCxJQUFLO1lBQzNDLElBQUksQ0FBQ3dKLFVBQVUsQ0FBQ3JFLE1BQU14RSxLQUFLLENBQUNYLEVBQUUsRUFBRUEsR0FBR3FQO1FBQ3JDO0lBQ0YsRUFDQTs7R0FFQztJQUdEL00sT0FBT2tILFVBQVUsR0FBRyxTQUFTQSxXQUFXL0osSUFBSSxFQUFFa0IsS0FBSyxFQUFFME8sWUFBWTtRQUMvRCxJQUFJQSxpQkFBaUIsS0FBSyxHQUFHO1lBQzNCQSxlQUFlLElBQUksQ0FBQzlCLE9BQU8sQ0FBQ3BMLEtBQUs7UUFDbkM7UUFFQSxJQUFJMUMsS0FBSzBGLEtBQUssRUFBRTtZQUNkLElBQUlWLFNBQVNoRjtZQUNiLElBQUk2UCxxQkFBcUJEO1lBRXpCLElBQUk1UCxLQUFLd0MsSUFBSSxLQUFLLGlCQUFpQnhDLEtBQUt3QyxJQUFJLEtBQUssYUFBYTtnQkFDNUQsSUFBSXNOLGtCQUFrQmpCLDJCQUEyQmUsY0FBYzFPLFFBQVEsMERBQTBEO2dCQUdqSTJPLHFCQUFxQnBCLFlBQVltQixjQUFjNUssT0FBT1QsUUFBUSxDQUFDO29CQUM3RFcsVUFBVTtnQkFDWixJQUFJNEs7Z0JBRUosSUFBSUQsdUJBQXVCLE9BQU87b0JBQ2hDLE9BQU87Z0JBQ1Q7Z0JBRUEsSUFBSSxDQUFDRSxVQUFVLENBQUMvUCxNQUFNOFAsaUJBQWlCRDtZQUN6QztZQUVBLElBQUksQ0FBQ0YsV0FBVyxDQUFDM0ssT0FBT1UsS0FBSyxFQUFFbUs7WUFDL0IsT0FBT0E7UUFDVDtRQUVBLElBQUlHLFVBQVVoUSxLQUFLdUUsUUFBUTtRQUMzQixJQUFJLENBQUN5TCxTQUFTLE9BQU87UUFDckIsSUFBSUMsaUJBQWlCcEIsMkJBQTJCZSxjQUFjMU87UUFFOUQsSUFBSWdQLGFBQWF6QixZQUFZbUIsY0FBY0ksU0FBU0M7UUFFcEQsSUFBSUMsZUFBZSxPQUFPO1lBQ3hCLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQ2QsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDVyxVQUFVLENBQUMvUCxNQUFNaVEsZ0JBQWdCQztRQUN0QyxPQUFPQTtJQUNUO0lBRUFyTixPQUFPa04sVUFBVSxHQUFHLFNBQVNBLFdBQVcvUCxJQUFJLEVBQUVrQixLQUFLLEVBQUVxTCxPQUFPO1FBQzFEdk0sS0FBS3VELFVBQVUsR0FBR2dKLFNBQVMsc0dBQXNHO1FBQ2pJLCtDQUErQztRQUUvQyxJQUFJdk0sS0FBS0gsT0FBTyxDQUFDbUYsTUFBTSxZQUFZd0UsWUFBWTtZQUM3QyxJQUFJLENBQUNvRixRQUFRLENBQUNyRyxNQUFNLENBQUNySCxPQUFPLEdBQUdxTDtRQUNqQztJQUNGLEVBQ0E7O0dBRUM7SUFHRDFKLE9BQU9tSCxVQUFVLEdBQUcsU0FBU0EsV0FBV3VDLE9BQU87UUFDN0MsSUFBSTdKLFFBQVEsSUFBSSxDQUFDb0wsT0FBTyxDQUFDcEwsS0FBSztRQUM5QixJQUFJeEIsUUFBUSxJQUFJLENBQUM0RSxPQUFPLENBQUN5RztRQUN6QixJQUFJckwsVUFBVSxDQUFDLEdBQUcsT0FBTztRQUN6QndCLE1BQU1zSCxVQUFVLENBQUM5STtRQUNqQixJQUFJLENBQUMwTixRQUFRLENBQUNyRyxNQUFNLENBQUNySCxPQUFPO1FBQzVCLE9BQU87SUFDVCxFQUNBOztHQUVDO0lBR0QyQixPQUFPaUQsT0FBTyxHQUFHLFNBQVNBLFFBQVF5RyxPQUFPO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDcUMsUUFBUSxDQUFDOUksT0FBTyxDQUFDeUc7SUFDL0IsRUFDQTs7R0FFQztJQUdEMUosT0FBT2dDLFdBQVcsR0FBRyxTQUFTQSxZQUFZMEgsT0FBTyxFQUFFdk0sSUFBSTtRQUNyRCxJQUFJa0IsUUFBUSxJQUFJLENBQUM0RSxPQUFPLENBQUN5RztRQUN6QixJQUFJckwsVUFBVSxDQUFDLEdBQUcsT0FBTztRQUN6QixJQUFJLENBQUM0TSxPQUFPLENBQUNwTCxLQUFLLENBQUNzSCxVQUFVLENBQUM5STtRQUM5QixJQUFJLENBQUMwTixRQUFRLENBQUNyRyxNQUFNLENBQUNySCxPQUFPO1FBQzVCLE9BQU8sSUFBSSxDQUFDNkksVUFBVSxDQUFDL0osTUFBTWtCO0lBQy9CLEVBQ0E7O0dBRUM7SUFHRDJCLE9BQU9zTixRQUFRLEdBQUcsU0FBU0E7UUFDekIsT0FBTyxJQUFJLENBQUNyQyxPQUFPLENBQUNwTCxLQUFLLENBQUNrTSxRQUFRO0lBQ3BDO0lBRUEsT0FBT087QUFDVDtBQUVBLElBQUlpQixrQkFBa0I7QUFFdEIsSUFBSUMsTUFDSixXQUFXLEdBQ1g7SUFDRSxTQUFTQSxJQUFJeFEsT0FBTztRQUNsQixJQUFJLENBQUNxRSxFQUFFLEdBQUdrTTtRQUNWLElBQUksQ0FBQ0UsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDclEsT0FBTyxHQUFHLElBQUltSztRQUNuQixJQUFJLENBQUN2SyxPQUFPLEdBQUc7WUFDYnFFLElBQUk7Z0JBQ0ZpSSxRQUFRO1lBQ1Y7WUFDQU4sa0JBQWtCQTtZQUNsQmxKLFVBQVUvRCxxREFBV0EsR0FBR3VRLGNBQWM7WUFDdENsUCxTQUFTLEVBQUU7UUFDYjtRQUNBLElBQUksQ0FBQytELFVBQVUsR0FBRzZILGlCQUFpQjtZQUNqQ00sUUFBUTtRQUNWO1FBRUEsSUFBSyxJQUFJNUwsSUFBSSxHQUFHQSxJQUFJTixRQUFRTyxNQUFNLEVBQUVELElBQUs7WUFDdkMsSUFBSSxDQUFDTixPQUFPLENBQUN5SyxHQUFHLENBQUN6SyxPQUFPLENBQUNNLEVBQUUsRUFBRTtnQkFDM0JzSixPQUFPO1lBQ1Q7UUFDRjtRQUVBLElBQUksQ0FBQzBHLEtBQUssQ0FBQzFRO0lBQ2I7SUFDQTs7OztHQUlDLEdBR0QsSUFBSWdELFNBQVN3TixJQUFJdk4sU0FBUztJQUUxQkQsT0FBTzBOLEtBQUssR0FBRyxTQUFTQSxNQUFNMVEsT0FBTztRQUNuQyxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUN0QkEsVUFBVSxDQUFDO1FBQ2I7UUFFQSxJQUFJQSxRQUFRZ00sZ0JBQWdCLEVBQUU7WUFDNUIsSUFBSSxDQUFDaE0sT0FBTyxDQUFDZ00sZ0JBQWdCLEdBQUdoTSxRQUFRZ00sZ0JBQWdCO1FBQzFEO1FBRUEsSUFBSWhNLFFBQVFxRSxFQUFFLEVBQUU7WUFDZCxJQUFJLENBQUNyRSxPQUFPLENBQUNxRSxFQUFFLEdBQUd2Riw4RUFBUUEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDa0IsT0FBTyxDQUFDcUUsRUFBRSxFQUFFckUsUUFBUXFFLEVBQUU7UUFDNUQ7UUFFQSxJQUFJckUsUUFBUWdNLGdCQUFnQixJQUFJaE0sUUFBUXFFLEVBQUUsRUFBRTtZQUMxQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNuRSxPQUFPLENBQUNnTSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNoTSxPQUFPLENBQUNxRSxFQUFFO1FBQ2pFO1FBRUEsSUFBSXJFLFFBQVFzTixjQUFjLElBQUksTUFBTSxJQUFJLENBQUN0TixPQUFPLENBQUNzTixjQUFjLEdBQUd0TixRQUFRc04sY0FBYztRQUV4RixJQUFJLGNBQWN0TixTQUFTO1lBQ3pCLElBQUksQ0FBQ0EsT0FBTyxDQUFDOEMsUUFBUSxHQUFHOUMsUUFBUThDLFFBQVE7UUFDMUMsRUFBRSx5Q0FBeUM7UUFHM0MsSUFBSTlDLFFBQVFJLE9BQU8sRUFBRSxJQUFJLENBQUN5SyxHQUFHLENBQUN0RCxLQUFLLENBQUMsSUFBSSxFQUFFdkgsUUFBUUksT0FBTztRQUN6RCxPQUFPLElBQUk7SUFDYixFQUNBOztHQUVDO0lBR0Q0QyxPQUFPMk4sZ0JBQWdCLEdBQUcsU0FBU0EsaUJBQWlCbkwsTUFBTSxFQUFFeEYsT0FBTztRQUNqRSxJQUFJQSxZQUFZLEtBQUssR0FBRztZQUN0QkEsVUFBVSxDQUFDO1FBQ2I7UUFFQSxJQUFJd0IsV0FBV3hCLFNBQ1hxQixRQUFRRyxTQUFTSCxLQUFLO1FBRTFCLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCQSxRQUFRaUssT0FBT2pLLEtBQUssS0FBSyxJQUFJLElBQUlpSyxPQUFPakssS0FBSyxHQUFHO1FBQ2xEO1FBRUEsSUFBSXdCLFFBQVEsSUFBSThHLFdBQVduRSxRQUFRMUcsOEVBQVFBLENBQUMsQ0FBQyxHQUFHa0IsU0FBUztZQUN2REMsS0FBSyxJQUFJO1lBQ1RrRSxZQUFZbkUsUUFBUW1FLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVU7WUFDakRtSixnQkFBZ0IsSUFBSSxDQUFDdE4sT0FBTyxDQUFDc04sY0FBYztZQUMzQ3hLLFVBQVUsSUFBSSxDQUFDOUMsT0FBTyxDQUFDOEMsUUFBUTtZQUMvQnpCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJLENBQUNqQixPQUFPLENBQUN1SyxjQUFjLENBQUM5SDtRQUM1QixPQUFPQTtJQUNULEVBQ0E7O0dBRUM7SUFHREcsT0FBTzROLGdCQUFnQixHQUFHLFNBQVNBLGlCQUFpQi9OLEtBQUs7UUFDdkRBLE1BQU1rSCxNQUFNO1FBQ1p1QixPQUFPN0gsTUFBTSxDQUFDWjtRQUNkLE9BQU8sSUFBSTtJQUNiLEVBQ0E7OztHQUdDO0lBR0RHLE9BQU9sRCxVQUFVLEdBQUcsU0FBUytRLGFBQWFoUixJQUFJLEVBQUVMLEtBQUssRUFBRVEsT0FBTztRQUM1RCxJQUFJUixVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUSxDQUFDO1FBQ1g7UUFFQSxJQUFJUSxZQUFZLEtBQUssR0FBRztZQUN0QkEsVUFBVSxDQUFDO1FBQ2I7UUFFQSw4Q0FBOEM7UUFDOUMsSUFBSSxPQUFPSCxTQUFTLFVBQVU7WUFDNUIsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ29ELFdBQVdyRCxNQUFNTDtRQUMxQztRQUVBLElBQUkrSSxjQUFjekosOEVBQVFBLENBQUMsQ0FBQyxHQUFHa0IsU0FBUztZQUN0Q0gsTUFBTUE7WUFDTkksS0FBSyxJQUFJO1lBQ1Q2QyxVQUFVLElBQUksQ0FBQzlDLE9BQU8sQ0FBQzhDLFFBQVE7UUFDakM7UUFFQSxJQUFJLENBQUN5RixZQUFZcEUsVUFBVSxFQUFFb0UsWUFBWXBFLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVU7UUFDckUsSUFBSSxDQUFDb0UsWUFBWUQsT0FBTyxFQUFFQyxZQUFZRCxPQUFPLEdBQUcsQ0FBQztRQUNqRCxJQUFJLENBQUNDLFlBQVl0QixTQUFTLEVBQUVzQixZQUFZdEIsU0FBUyxHQUFHLENBQUM7UUFFckQsSUFBSTlHLE9BQU9MLFdBQVdELE1BQU1MLE9BQU8rSTtRQUVuQyxJQUFJcEksTUFBTSxJQUFJLENBQUNDLE9BQU8sQ0FBQytGLGFBQWEsQ0FBQ2hHO1FBQ3JDLE9BQU9BO0lBQ1QsRUFDQTs7R0FFQztJQUdENkMsT0FBTzZILEdBQUcsR0FBRyxTQUFTQTtRQUNwQixJQUFJN0csUUFBUSxJQUFJO1FBRWhCLElBQUssSUFBSThNLE9BQU90SixVQUFVN0csTUFBTSxFQUFFUCxVQUFVLElBQUlYLE1BQU1xUixPQUFPQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7WUFDMUYzUSxPQUFPLENBQUMyUSxLQUFLLEdBQUd2SixTQUFTLENBQUN1SixLQUFLO1FBQ2pDO1FBRUEzUSxRQUFRNEksT0FBTyxDQUFDLFNBQVVpQyxNQUFNO1lBQzlCakgsTUFBTTVELE9BQU8sQ0FBQ3lLLEdBQUcsQ0FBQ0k7UUFDcEI7UUFDQSxPQUFPLElBQUk7SUFDYjtJQUVBLE9BQU91RjtBQUNUO0FBRUEsSUFBSVEsWUFBWSxTQUFTQSxVQUFVaFIsT0FBTztJQUN4QyxPQUFPLElBQUl3USxJQUFJeFE7QUFDakI7QUFFQTs7OztDQUlDLEdBRUQsSUFBSWlSLGdCQUNKLFdBQVcsR0FDWDtJQUNFLFNBQVNBO1FBQ1AsSUFBSSxDQUFDdFEsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDMkssTUFBTSxHQUFHLElBQUk0RjtJQUNwQjtJQUVBLElBQUlsTyxTQUFTaU8sY0FBY2hPLFNBQVM7SUFFcENELE9BQU9pQyxHQUFHLEdBQUcsU0FBU0EsSUFBSXZDLEdBQUc7UUFDM0IsSUFBSXlPLFFBQVEsSUFBSSxDQUFDN0YsTUFBTSxDQUFDckcsR0FBRyxDQUFDdkM7UUFDNUIsT0FBT3lPLFNBQVNBLE1BQU10TyxLQUFLO0lBQzdCO0lBRUFHLE9BQU8rQyxHQUFHLEdBQUcsU0FBU0EsSUFBSXJELEdBQUcsRUFBRUcsS0FBSztRQUNsQyxJQUFJLElBQUksQ0FBQ3lJLE1BQU0sQ0FBQzhGLEdBQUcsQ0FBQzFPLE1BQU07UUFDMUIsSUFBSSxDQUFDL0IsTUFBTTtRQUNYLElBQUksQ0FBQzJLLE1BQU0sQ0FBQ3pHLEdBQUcsQ0FBQ25DLEtBQUs7WUFDbkJHLE9BQU9BO1lBQ1B3TyxNQUFNO1FBQ1I7SUFDRjtJQUVBck8sT0FBT3NPLE1BQU0sR0FBRyxTQUFTQSxPQUFPNU8sR0FBRztRQUNqQyxJQUFJeU8sUUFBUSxJQUFJLENBQUM3RixNQUFNLENBQUNyRyxHQUFHLENBQUN2QztRQUU1QixJQUFJeU8sT0FBTztZQUNULElBQUlBLE1BQU1FLElBQUksS0FBSyxHQUFHO2dCQUNwQkYsTUFBTXRPLEtBQUssQ0FBQ2dILE1BQU07WUFDcEI7WUFFQXNILE1BQU1FLElBQUk7WUFDVixPQUFPRixNQUFNdE8sS0FBSztRQUNwQjtRQUVBN0Qsd0RBQU9BLENBQUMsT0FBTztRQUNmLE9BQU9rRTtJQUNUO0lBRUFGLE9BQU91TyxRQUFRLEdBQUcsU0FBU0EsU0FBUzdPLEdBQUc7UUFDckMsSUFBSXlPLFFBQVEsSUFBSSxDQUFDN0YsTUFBTSxDQUFDckcsR0FBRyxDQUFDdkM7UUFFNUIsSUFBSXlPLE9BQU87WUFDVCxJQUFJQSxNQUFNRSxJQUFJLEdBQUcsR0FBRztnQkFDbEJGLE1BQU1FLElBQUk7Z0JBQ1YsSUFBSUYsTUFBTUUsSUFBSSxLQUFLLEdBQUdGLE1BQU10TyxLQUFLLENBQUNrSCxNQUFNO1lBQzFDO1FBQ0YsT0FBTztZQUNML0ssd0RBQU9BLENBQUMsT0FBTztRQUNqQjtJQUNGO0lBRUFDLGtGQUFZQSxDQUFDZ1MsZUFBZTtRQUFDO1lBQzNCdk8sS0FBSztZQUNMdUMsS0FBSyxTQUFTQTtnQkFDWixPQUFPLElBQUksQ0FBQ3RFLE1BQU07WUFDcEI7UUFDRjtLQUFFO0lBRUYsT0FBT3NRO0FBQ1Q7QUFFQTs7O0FBR0EsR0FDQSxJQUFJTyxtQkFBbUIsT0FBT2xQLFFBQVEsWUFBWUEsT0FBTyxRQUFRLFlBQVlBO0FBRTdFOztDQUVDLEdBQ0QsU0FBU21QLGlCQUFpQmpNLE1BQU07SUFDOUIsSUFBSWtNLEtBQUs7SUFFVCxJQUFLLElBQUloUCxPQUFPOEMsT0FBUTtRQUN0QixJQUFJakYsUUFBUWlGLE1BQU0sQ0FBQzlDLElBQUk7UUFDdkIsSUFBSUMsT0FBTyxPQUFPcEM7UUFFbEIsSUFBSW9DLFNBQVMsWUFBWTtZQUN2QixJQUFJLENBQUMrTyxJQUFJQSxLQUFLLENBQUM7WUFDZkEsRUFBRSxDQUFDaFAsSUFBSSxHQUFHbkM7UUFDWixPQUFPLElBQUlvQyxTQUFTLFlBQVlwQyxVQUFVLFFBQVEsQ0FBQ2QsTUFBTUMsT0FBTyxDQUFDYSxRQUFRO1lBQ3ZFLElBQUlvUixZQUFZRixpQkFBaUJsUjtZQUVqQyxJQUFJb1IsV0FBVztnQkFDYixJQUFJLENBQUNELElBQUlBLEtBQUssQ0FBQztnQkFDZkEsRUFBRSxDQUFDaFAsSUFBSSxHQUFHaVA7WUFDWjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRDtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsSUFBSXJRLFFBQVEyUDtBQUVaLGlFQUFlM1AsS0FBS0EsRUFBQztBQUN5SSIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYXZlbC1mZS8uL25vZGVfbW9kdWxlcy9qc3MvZGlzdC9qc3MuZXNtLmpzPzc0YTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IGlzSW5Ccm93c2VyIGZyb20gJ2lzLWluLWJyb3dzZXInO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MnO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcblxudmFyIHBsYWluT2JqZWN0Q29uc3RydXJjdG9yID0ge30uY29uc3RydWN0b3I7XG5mdW5jdGlvbiBjbG9uZVN0eWxlKHN0eWxlKSB7XG4gIGlmIChzdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHJldHVybiBzdHlsZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSByZXR1cm4gc3R5bGUubWFwKGNsb25lU3R5bGUpO1xuICBpZiAoc3R5bGUuY29uc3RydWN0b3IgIT09IHBsYWluT2JqZWN0Q29uc3RydXJjdG9yKSByZXR1cm4gc3R5bGU7XG4gIHZhciBuZXdTdHlsZSA9IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICBuZXdTdHlsZVtuYW1lXSA9IGNsb25lU3R5bGUoc3R5bGVbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0eWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJ1bGUgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICBuYW1lID0gJ3VubmFtZWQnO1xuICB9XG5cbiAgdmFyIGpzcyA9IG9wdGlvbnMuanNzO1xuICB2YXIgZGVjbENvcHkgPSBjbG9uZVN0eWxlKGRlY2wpO1xuICB2YXIgcnVsZSA9IGpzcy5wbHVnaW5zLm9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsQ29weSwgb3B0aW9ucyk7XG4gIGlmIChydWxlKSByZXR1cm4gcnVsZTsgLy8gSXQgaXMgYW4gYXQtcnVsZSBhbmQgaXQgaGFzIG5vIGluc3RhbmNlLlxuXG4gIGlmIChuYW1lWzBdID09PSAnQCcpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gcnVsZSBcIiArIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBqb2luID0gZnVuY3Rpb24gam9pbih2YWx1ZSwgYnkpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBSZW1vdmUgIWltcG9ydGFudCBmcm9tIHRoZSB2YWx1ZSwgaXQgd2lsbCBiZSByZWFkZGVkIGxhdGVyLlxuICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gYnk7XG4gICAgcmVzdWx0ICs9IHZhbHVlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIEpTUyBhcnJheSB2YWx1ZSB0byBhIENTUyBzdHJpbmcuXG4gKlxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXV1gID4gYG1hcmdpbjogNXB4IDEwcHg7YFxuICogYGJvcmRlcjogWycxcHgnLCAnMnB4J11gID4gYGJvcmRlcjogMXB4LCAycHg7YFxuICogYG1hcmdpbjogW1snNXB4JywgJzEwcHgnXSwgJyFpbXBvcnRhbnQnXWAgPiBgbWFyZ2luOiA1cHggMTBweCAhaW1wb3J0YW50O2BcbiAqIGBjb2xvcjogWydyZWQnLCAhaW1wb3J0YW50XWAgPiBgY29sb3I6IHJlZCAhaW1wb3J0YW50O2BcbiAqL1xuXG5cbnZhciB0b0Nzc1ZhbHVlID0gZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIHZhciBjc3NWYWx1ZSA9ICcnOyAvLyBTdXBwb3J0IHNwYWNlIHNlcGFyYXRlZCB2YWx1ZXMgdmlhIGBbWyc1cHgnLCAnMTBweCddXWAuXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgICAgaWYgKGNzc1ZhbHVlKSBjc3NWYWx1ZSArPSAnLCAnO1xuICAgICAgY3NzVmFsdWUgKz0gam9pbih2YWx1ZVtpXSwgJyAnKTtcbiAgICB9XG4gIH0gZWxzZSBjc3NWYWx1ZSA9IGpvaW4odmFsdWUsICcsICcpOyAvLyBBZGQgIWltcG9ydGFudCwgYmVjYXVzZSBpdCB3YXMgaWdub3JlZC5cblxuXG4gIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVicmVhazogJycsXG4gICAgICBzcGFjZTogJydcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lYnJlYWs6ICdcXG4nLFxuICAgIHNwYWNlOiAnICdcbiAgfTtcbn1cblxuLyoqXG4gKiBJbmRlbnQgYSBzdHJpbmcuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9hcnJheS1qb2luLXZzLWZvclxuICovXG5cbmZ1bmN0aW9uIGluZGVudFN0cihzdHIsIGluZGVudCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGluZGVudDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCArPSAnICAnO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHN0cjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBSdWxlIHRvIENTUyBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiB0b0NzcyhzZWxlY3Rvciwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKCFzdHlsZSkgcmV0dXJuIHJlc3VsdDtcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJGluZGVudCA9IF9vcHRpb25zLmluZGVudCxcbiAgICAgIGluZGVudCA9IF9vcHRpb25zJGluZGVudCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJGluZGVudDtcbiAgdmFyIGZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcztcblxuICBpZiAob3B0aW9ucy5mb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgaW5kZW50ID0gLUluZmluaXR5O1xuICB9XG5cbiAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhayxcbiAgICAgIHNwYWNlID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLnNwYWNlO1xuXG4gIGlmIChzZWxlY3RvcikgaW5kZW50Kys7IC8vIEFwcGx5IGZhbGxiYWNrcyBmaXJzdC5cblxuICBpZiAoZmFsbGJhY2tzKSB7XG4gICAgLy8gQXJyYXkgc3ludGF4IHtmYWxsYmFja3M6IFt7cHJvcDogdmFsdWV9XX1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbaW5kZXhdO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmFsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxsYmFja1twcm9wXTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gbGluZWJyZWFrO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihwcm9wICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUodmFsdWUpICsgXCI7XCIsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9iamVjdCBzeW50YXgge2ZhbGxiYWNrczoge3Byb3A6IHZhbHVlfX1cbiAgICAgIGZvciAodmFyIF9wcm9wIGluIGZhbGxiYWNrcykge1xuICAgICAgICB2YXIgX3ZhbHVlID0gZmFsbGJhY2tzW19wcm9wXTtcblxuICAgICAgICBpZiAoX3ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gbGluZWJyZWFrO1xuICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIoX3Byb3AgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZShfdmFsdWUpICsgXCI7XCIsIGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcDIgaW4gc3R5bGUpIHtcbiAgICB2YXIgX3ZhbHVlMiA9IHN0eWxlW19wcm9wMl07XG5cbiAgICBpZiAoX3ZhbHVlMiAhPSBudWxsICYmIF9wcm9wMiAhPT0gJ2ZhbGxiYWNrcycpIHtcbiAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBsaW5lYnJlYWs7XG4gICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wMiArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKF92YWx1ZTIpICsgXCI7XCIsIGluZGVudCk7XG4gICAgfVxuICB9IC8vIEFsbG93IGVtcHR5IHN0eWxlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgZHluYW1pY2FsbHkuXG5cblxuICBpZiAoIXJlc3VsdCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSByZXR1cm4gcmVzdWx0OyAvLyBXaGVuIHJ1bGUgaXMgYmVpbmcgc3RyaW5naWZpZWQgYmVmb3JlIHNlbGVjdG9yIHdhcyBkZWZpbmVkLlxuXG4gIGlmICghc2VsZWN0b3IpIHJldHVybiByZXN1bHQ7XG4gIGluZGVudC0tO1xuICBpZiAocmVzdWx0KSByZXN1bHQgPSBcIlwiICsgbGluZWJyZWFrICsgcmVzdWx0ICsgbGluZWJyZWFrO1xuICByZXR1cm4gaW5kZW50U3RyKFwiXCIgKyBzZWxlY3RvciArIHNwYWNlICsgXCJ7XCIgKyByZXN1bHQsIGluZGVudCkgKyBpbmRlbnRTdHIoJ30nLCBpbmRlbnQpO1xufVxuXG52YXIgZXNjYXBlUmVnZXggPSAvKFtbXFxdLiMqJD48K349fF46KCksXCInYFxcc10pL2c7XG52YXIgbmF0aXZlRXNjYXBlID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTLmVzY2FwZTtcbnZhciBlc2NhcGUgPSAoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gbmF0aXZlRXNjYXBlID8gbmF0aXZlRXNjYXBlKHN0cikgOiBzdHIucmVwbGFjZShlc2NhcGVSZWdleCwgJ1xcXFwkMScpO1xufSk7XG5cbnZhciBCYXNlU3R5bGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdmFyIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIGlmIChzaGVldCkgdGhpcy5yZW5kZXJlciA9IHNoZWV0LnJlbmRlcmVyO2Vsc2UgaWYgKFJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQmFzZVN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnByb3AgPSBmdW5jdGlvbiBwcm9wKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgLy8gSXQncyBhIGdldHRlci5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuc3R5bGVbbmFtZV07IC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG5cbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zID8gb3B0aW9ucy5mb3JjZSA6IGZhbHNlO1xuICAgIGlmICghZm9yY2UgJiYgdGhpcy5zdHlsZVtuYW1lXSA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMucHJvY2VzcyAhPT0gZmFsc2UpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uQ2hhbmdlVmFsdWUodmFsdWUsIG5hbWUsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBpc0VtcHR5ID0gbmV3VmFsdWUgPT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gZmFsc2U7XG4gICAgdmFyIGlzRGVmaW5lZCA9IG5hbWUgaW4gdGhpcy5zdHlsZTsgLy8gVmFsdWUgaXMgZW1wdHkgYW5kIHdhc24ndCBkZWZpbmVkIGJlZm9yZS5cblxuICAgIGlmIChpc0VtcHR5ICYmICFpc0RlZmluZWQgJiYgIWZvcmNlKSByZXR1cm4gdGhpczsgLy8gV2UgYXJlIGdvaW5nIHRvIHJlbW92ZSB0aGlzIHZhbHVlLlxuXG4gICAgdmFyIHJlbW92ZSA9IGlzRW1wdHkgJiYgaXNEZWZpbmVkO1xuICAgIGlmIChyZW1vdmUpIGRlbGV0ZSB0aGlzLnN0eWxlW25hbWVdO2Vsc2UgdGhpcy5zdHlsZVtuYW1lXSA9IG5ld1ZhbHVlOyAvLyBSZW5kZXJhYmxlIGlzIGRlZmluZWQgaWYgU3R5bGVTaGVldCBvcHRpb24gYGxpbmtgIGlzIHRydWUuXG5cbiAgICBpZiAodGhpcy5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIGlmIChyZW1vdmUpIHRoaXMucmVuZGVyZXIucmVtb3ZlUHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lKTtlbHNlIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5yZW5kZXJhYmxlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQuYXR0YWNoZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBSdWxlIGlzIG5vdCBsaW5rZWQuIE1pc3Npbmcgc2hlZXQgb3B0aW9uIFwibGluazogdHJ1ZVwiLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU3R5bGVSdWxlO1xufSgpO1xudmFyIFN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3R5bGVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3R5bGVSdWxlLmNhbGwodGhpcywga2V5LCBzdHlsZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yLFxuICAgICAgICBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB9IGVsc2UgaWYgKHNjb3BlZCAhPT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmlkID0gZ2VuZXJhdGVJZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgc2hlZXQpO1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gXCIuXCIgKyBlc2NhcGUoX3RoaXMuaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICogQXR0ZW50aW9uOiB1c2UgdGhpcyB3aXRoIGNhdXRpb24uIE1vc3QgYnJvd3NlcnMgZGlkbid0IGltcGxlbWVudFxuICAgKiBzZWxlY3RvclRleHQgc2V0dGVyLCBzbyB0aGlzIG1heSByZXN1bHQgaW4gcmVyZW5kZXJpbmcgb2YgZW50aXJlIFN0eWxlIFNoZWV0LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8yID0gU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQXBwbHkgcnVsZSB0byBhbiBlbGVtZW50IGlubGluZS5cbiAgICovXG4gIF9wcm90bzIuYXBwbHlUbyA9IGZ1bmN0aW9uIGFwcGx5VG8ocmVuZGVyYWJsZSkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHZhciBqc29uID0gdGhpcy50b0pTT04oKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KHJlbmRlcmFibGUsIHByb3AsIGpzb25bcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGUuXG4gICAqIEZhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogVXNlZnVsIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBqc29uID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3R5bGVbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykganNvbltwcm9wXSA9IHZhbHVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBqc29uW3Byb3BdID0gdG9Dc3NWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLnNlbGVjdG9yVGV4dCwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUnVsZSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnNlbGVjdG9yVGV4dCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgIGlmICghcmVuZGVyYWJsZSB8fCAhcmVuZGVyZXIpIHJldHVybjtcbiAgICAgIHZhciBoYXNDaGFuZ2VkID0gcmVuZGVyZXIuc2V0U2VsZWN0b3IocmVuZGVyYWJsZSwgc2VsZWN0b3IpOyAvLyBJZiBzZWxlY3RvciBzZXR0ZXIgaXMgbm90IGltcGxlbWVudGVkLCByZXJlbmRlciB0aGUgcnVsZS5cblxuICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlcGxhY2VSdWxlKHJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5TdHlsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoa2V5WzBdID09PSAnQCcgfHwgb3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBhdFJlZ0V4cCA9IC9AKFtcXHctXSspLztcbi8qKlxuICogQ29uZGl0aW9uYWwgcnVsZSBmb3IgQG1lZGlhLCBAc3VwcG9ydHNcbiAqL1xuXG52YXIgQ29uZGl0aW9uYWxSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbmFsJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdmFyIGF0TWF0Y2ggPSBrZXkubWF0Y2goYXRSZWdFeHApO1xuICAgIHRoaXMuYXQgPSBhdE1hdGNoID8gYXRNYXRjaFsxXSA6ICd1bmtub3duJzsgLy8gS2V5IG1pZ2h0IGNvbnRhaW4gYSB1bmlxdWUgc3VmZml4IGluIGNhc2UgdGhlIGBuYW1lYCBwYXNzZWQgYnkgdXNlciB3YXMgZHVwbGljYXRlLlxuXG4gICAgdGhpcy5xdWVyeSA9IG9wdGlvbnMubmFtZSB8fCBcIkBcIiArIHRoaXMuYXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGVzW25hbWVdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQ29uZGl0aW9uYWxSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0UnVsZSA9IGZ1bmN0aW9uIGdldFJ1bGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBydWxlLCBydW4gcGx1Z2lucy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBuZXdSdWxlID0gdGhpcy5ydWxlcy5yZXBsYWNlKG5hbWUsIHN0eWxlLCBvcHRpb25zKTtcbiAgICBpZiAobmV3UnVsZSkgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUobmV3UnVsZSk7XG4gICAgcmV0dXJuIG5ld1J1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeSArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyB0aGlzLnF1ZXJ5ICsgXCIge1wiICsgbGluZWJyZWFrICsgY2hpbGRyZW4gKyBsaW5lYnJlYWsgKyBcIn1cIiA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbFJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwID0gL0Bjb250YWluZXJ8QG1lZGlhfEBzdXBwb3J0c1xccysvO1xudmFyIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwLnRlc3Qoa2V5KSA/IG5ldyBDb25kaXRpb25hbFJ1bGUoa2V5LCBzdHlsZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMSA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBuYW1lUmVnRXhwID0gL0BrZXlmcmFtZXNcXHMrKFtcXHctXSspLztcbi8qKlxuICogUnVsZSBmb3IgQGtleWZyYW1lc1xuICovXG5cbnZhciBLZXlmcmFtZXNSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdrZXlmcmFtZXMnO1xuICAgIHRoaXMuYXQgPSAnQGtleWZyYW1lcyc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBuYW1lTWF0Y2ggPSBrZXkubWF0Y2gobmFtZVJlZ0V4cCk7XG5cbiAgICBpZiAobmFtZU1hdGNoICYmIG5hbWVNYXRjaFsxXSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZU1hdGNoWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hbWUgPSAnbm9uYW1lJztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQmFkIGtleWZyYW1lcyBuYW1lIFwiICsga2V5KSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IHRoaXMudHlwZSArIFwiLVwiICsgdGhpcy5uYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG4gICAgdGhpcy5pZCA9IHNjb3BlZCA9PT0gZmFsc2UgPyB0aGlzLm5hbWUgOiBlc2NhcGUoZ2VuZXJhdGVJZCh0aGlzLCBzaGVldCkpO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZnJhbWVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBmcmFtZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZXNSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMTtcbiAgICB9XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChjaGlsZHJlbikgY2hpbGRyZW4gPSBcIlwiICsgbGluZWJyZWFrICsgY2hpbGRyZW4gKyBsaW5lYnJlYWs7XG4gICAgcmV0dXJuIHRoaXMuYXQgKyBcIiBcIiArIHRoaXMuaWQgKyBcIiB7XCIgKyBjaGlsZHJlbiArIFwifVwiO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZXNSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCQxID0gL0BrZXlmcmFtZXNcXHMrLztcbnZhciByZWZSZWdFeHAgPSAvXFwkKFtcXHctXSspL2c7XG5cbnZhciBmaW5kUmVmZXJlbmNlZEtleWZyYW1lID0gZnVuY3Rpb24gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIGtleWZyYW1lcykge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UocmVmUmVnRXhwLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIGtleWZyYW1lcykge1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFJlZmVyZW5jZWQga2V5ZnJhbWVzIHJ1bGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZC5cIikgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgcmVmZXJlbmNlIGZvciBhIGFuaW1hdGlvbiBuYW1lLlxuICovXG5cblxudmFyIHJlcGxhY2VSZWYgPSBmdW5jdGlvbiByZXBsYWNlUmVmKHN0eWxlLCBwcm9wLCBrZXlmcmFtZXMpIHtcbiAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gIHZhciByZWZLZXlmcmFtZSA9IGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsdWUsIGtleWZyYW1lcyk7XG5cbiAgaWYgKHJlZktleWZyYW1lICE9PSB2YWx1ZSkge1xuICAgIHN0eWxlW3Byb3BdID0gcmVmS2V5ZnJhbWU7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5LZXlmcmFtZXNSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXlSZWdFeHAkMS50ZXN0KGtleSkgPyBuZXcgS2V5ZnJhbWVzUnVsZShrZXksIGZyYW1lcywgb3B0aW9ucykgOiBudWxsO1xuICB9LFxuICAvLyBBbmltYXRpb24gbmFtZSByZWYgcmVwbGFjZXIuXG4gIG9uUHJvY2Vzc1N0eWxlOiBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnIHx8ICFzaGVldCkgcmV0dXJuIHN0eWxlO1xuICAgIGlmICgnYW5pbWF0aW9uLW5hbWUnIGluIHN0eWxlKSByZXBsYWNlUmVmKHN0eWxlLCAnYW5pbWF0aW9uLW5hbWUnLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIGlmICgnYW5pbWF0aW9uJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbicsIHNoZWV0LmtleWZyYW1lcyk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuICBvbkNoYW5nZVZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbCwgcHJvcCwgcnVsZSkge1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGlmICghc2hlZXQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICByZXR1cm4gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWwsIHNoZWV0LmtleWZyYW1lcyk7XG5cbiAgICAgIGNhc2UgJ2FuaW1hdGlvbi1uYW1lJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIEtleWZyYW1lUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoS2V5ZnJhbWVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVSdWxlKCkge1xuICAgIHJldHVybiBfQmFzZVN0eWxlUnVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgcmV0dXJuIEtleWZyYW1lUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luS2V5ZnJhbWVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbmV3IEtleWZyYW1lUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxudmFyIEZvbnRGYWNlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgdGhpcy5hdCA9ICdAZm9udC1mYWNlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEZvbnRGYWNlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3R5bGUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnN0eWxlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZVtpbmRleF0pO1xuICAgICAgICBpZiAodGhpcy5zdHlsZVtpbmRleCArIDFdKSBzdHIgKz0gbGluZWJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gRm9udEZhY2VSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCQyID0gL0Bmb250LWZhY2UvO1xudmFyIHBsdWdpbkZvbnRGYWNlUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXlSZWdFeHAkMi50ZXN0KGtleSkgPyBuZXcgRm9udEZhY2VSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIFZpZXdwb3J0UnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3ZpZXdwb3J0JztcbiAgICB0aGlzLmF0ID0gJ0B2aWV3cG9ydCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBWaWV3cG9ydFJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBWaWV3cG9ydFJ1bGU7XG59KCk7XG52YXIgcGx1Z2luVmlld3BvcnRSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSA9PT0gJ0B2aWV3cG9ydCcgfHwga2V5ID09PSAnQC1tcy12aWV3cG9ydCcgPyBuZXcgVmlld3BvcnRSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIDogbnVsbDtcbiAgfVxufTtcblxudmFyIFNpbXBsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc2ltcGxlJztcbiAgICB0aGlzLmlzUHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIHZhciBfcHJvdG8gPSBTaW1wbGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZVtpbmRleF0gKyBcIjtcIjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZSArIFwiO1wiO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xudmFyIGtleXNNYXAgPSB7XG4gICdAY2hhcnNldCc6IHRydWUsXG4gICdAaW1wb3J0JzogdHJ1ZSxcbiAgJ0BuYW1lc3BhY2UnOiB0cnVlXG59O1xudmFyIHBsdWdpblNpbXBsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5IGluIGtleXNNYXAgPyBuZXcgU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5zID0gW3BsdWdpblN0eWxlUnVsZSwgcGx1Z2luQ29uZGl0aW9uYWxSdWxlLCBwbHVnaW5LZXlmcmFtZXNSdWxlLCBwbHVnaW5LZXlmcmFtZVJ1bGUsIHBsdWdpbkZvbnRGYWNlUnVsZSwgcGx1Z2luVmlld3BvcnRSdWxlLCBwbHVnaW5TaW1wbGVSdWxlXTtcblxudmFyIGRlZmF1bHRVcGRhdGVPcHRpb25zID0ge1xuICBwcm9jZXNzOiB0cnVlXG59O1xudmFyIGZvcmNlVXBkYXRlT3B0aW9ucyA9IHtcbiAgZm9yY2U6IHRydWUsXG4gIHByb2Nlc3M6IHRydWVcbiAgLyoqXG4gICAqIENvbnRhaW5zIHJ1bGVzIG9iamVjdHMgYW5kIGFsbG93cyBhZGRpbmcvcmVtb3ZpbmcgZXRjLlxuICAgKiBJcyB1c2VkIGZvciBlLmcuIGJ5IGBTdHlsZVNoZWV0YCBvciBgQ29uZGl0aW9uYWxSdWxlYC5cbiAgICovXG5cbn07XG5cbnZhciBSdWxlTGlzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFJ1bGVzIHJlZ2lzdHJ5IGZvciBhY2Nlc3MgYnkgLmdldCgpIG1ldGhvZC5cbiAgLy8gSXQgY29udGFpbnMgdGhlIHNhbWUgcnVsZSByZWdpc3RlcmVkIGJ5IG5hbWUgYW5kIGJ5IHNlbGVjdG9yLlxuICAvLyBPcmlnaW5hbCBzdHlsZXMgb2JqZWN0LlxuICAvLyBVc2VkIHRvIGVuc3VyZSBjb3JyZWN0IHJ1bGVzIG9yZGVyLlxuICBmdW5jdGlvbiBSdWxlTGlzdChvcHRpb25zKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB0aGlzLnJhdyA9IHt9O1xuICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jbGFzc2VzID0gb3B0aW9ucy5jbGFzc2VzO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gb3B0aW9ucy5rZXlmcmFtZXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZS5cbiAgICpcbiAgICogV2lsbCBub3QgcmVuZGVyIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUnVsZUxpc3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgZGVjbCwgcnVsZU9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGFyZW50ID0gX3RoaXMkb3B0aW9ucy5wYXJlbnQsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9ucy5zaGVldCxcbiAgICAgICAganNzID0gX3RoaXMkb3B0aW9ucy5qc3MsXG4gICAgICAgIFJlbmRlcmVyID0gX3RoaXMkb3B0aW9ucy5SZW5kZXJlcixcbiAgICAgICAgZ2VuZXJhdGVJZCA9IF90aGlzJG9wdGlvbnMuZ2VuZXJhdGVJZCxcbiAgICAgICAgc2NvcGVkID0gX3RoaXMkb3B0aW9ucy5zY29wZWQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHtcbiAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3NlcyxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAganNzOiBqc3MsXG4gICAgICBSZW5kZXJlcjogUmVuZGVyZXIsXG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkLFxuICAgICAgc2NvcGVkOiBzY29wZWQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAga2V5ZnJhbWVzOiB0aGlzLmtleWZyYW1lcyxcbiAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWRcbiAgICB9LCBydWxlT3B0aW9ucyk7IC8vIFdoZW4gdXNlciB1c2VzIC5jcmVhdGVTdHlsZVNoZWV0KCksIGR1cGxpY2F0ZSBuYW1lcyBhcmUgbm90IHBvc3NpYmxlLCBidXRcbiAgICAvLyBgc2hlZXQuYWRkUnVsZSgpYCBvcGVucyB0aGUgZG9vciBmb3IgYW55IGR1cGxpY2F0ZSBydWxlIG5hbWUuIFdoZW4gdGhpcyBoYXBwZW5zXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHRoZSBrZXkgdW5pcXVlIHdpdGhpbiB0aGlzIFJ1bGVMaXN0IGluc3RhbmNlIHNjb3BlLlxuXG5cbiAgICB2YXIga2V5ID0gbmFtZTtcblxuICAgIGlmIChuYW1lIGluIHRoaXMucmF3KSB7XG4gICAgICBrZXkgPSBuYW1lICsgXCItZFwiICsgdGhpcy5jb3VudGVyKys7XG4gICAgfSAvLyBXZSBuZWVkIHRvIHNhdmUgdGhlIG9yaWdpbmFsIGRlY2wgYmVmb3JlIGNyZWF0aW5nIHRoZSBydWxlXG4gICAgLy8gYmVjYXVzZSBjYWNoZSBwbHVnaW4gbmVlZHMgdG8gdXNlIGl0IGFzIGEga2V5IHRvIHJldHVybiBhIGNhY2hlZCBydWxlLlxuXG5cbiAgICB0aGlzLnJhd1trZXldID0gZGVjbDtcblxuICAgIGlmIChrZXkgaW4gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAvLyBFLmcuIHJ1bGVzIGluc2lkZSBvZiBAbWVkaWEgY29udGFpbmVyXG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gXCIuXCIgKyBlc2NhcGUodGhpcy5jbGFzc2VzW2tleV0pO1xuICAgIH1cblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShrZXksIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5yZWdpc3RlcihydWxlKTtcbiAgICB2YXIgaW5kZXggPSBvcHRpb25zLmluZGV4ID09PSB1bmRlZmluZWQgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IG9wdGlvbnMuaW5kZXg7XG4gICAgdGhpcy5pbmRleC5zcGxpY2UoaW5kZXgsIDAsIHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIHJ1bGUuXG4gICAqIENyZWF0ZSBhIG5ldyBydWxlIGFuZCByZW1vdmUgb2xkIG9uZSBpbnN0ZWFkIG9mIG92ZXJ3cml0aW5nXG4gICAqIGJlY2F1c2Ugd2Ugd2FudCB0byBpbnZva2Ugb25DcmVhdGVSdWxlIGhvb2sgdG8gbWFrZSBwbHVnaW5zIHdvcmsuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIG9sZFJ1bGUgPSB0aGlzLmdldChuYW1lKTtcbiAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmluZGV4LmluZGV4T2Yob2xkUnVsZSk7XG5cbiAgICBpZiAob2xkUnVsZSkge1xuICAgICAgdGhpcy5yZW1vdmUob2xkUnVsZSk7XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSBydWxlT3B0aW9ucztcbiAgICBpZiAob2xkSW5kZXggIT09IC0xKSBvcHRpb25zID0gX2V4dGVuZHMoe30sIHJ1bGVPcHRpb25zLCB7XG4gICAgICBpbmRleDogb2xkSW5kZXhcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hZGQobmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUgYnkgbmFtZSBvciBzZWxlY3Rvci5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWVPclNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVPclNlbGVjdG9yXTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHJ1bGUpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXIocnVsZSk7XG4gICAgZGVsZXRlIHRoaXMucmF3W3J1bGUua2V5XTtcbiAgICB0aGlzLmluZGV4LnNwbGljZSh0aGlzLmluZGV4LmluZGV4T2YocnVsZSksIDEpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXguaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogUnVuIGBvblByb2Nlc3NSdWxlKClgIHBsdWdpbnMgb24gZXZlcnkgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgdmFyIHBsdWdpbnMgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnM7IC8vIFdlIG5lZWQgdG8gY2xvbmUgYXJyYXkgYmVjYXVzZSBpZiB3ZSBtb2RpZnkgdGhlIGluZGV4IHNvbWV3aGVyZSBlbHNlIGR1cmluZyBhIGxvb3BcbiAgICAvLyB3ZSBlbmQgdXAgd2l0aCB2ZXJ5IGhhcmQtdG8tdHJhY2stZG93biBzaWRlIGVmZmVjdHMuXG5cbiAgICB0aGlzLmluZGV4LnNsaWNlKDApLmZvckVhY2gocGx1Z2lucy5vblByb2Nlc3NSdWxlLCBwbHVnaW5zKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBydWxlIGluIGAubWFwYCwgYC5jbGFzc2VzYCBhbmQgYC5rZXlmcmFtZXNgIG1hcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIocnVsZSkge1xuICAgIHRoaXMubWFwW3J1bGUua2V5XSA9IHJ1bGU7XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl0gPSBydWxlO1xuICAgICAgaWYgKHJ1bGUuaWQpIHRoaXMuY2xhc3Nlc1tydWxlLmtleV0gPSBydWxlLmlkO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUgJiYgdGhpcy5rZXlmcmFtZXMpIHtcbiAgICAgIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV0gPSBydWxlLmlkO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKHJ1bGUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5rZXldO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldO1xuICAgIH0gZWxzZSBpZiAocnVsZSBpbnN0YW5jZW9mIEtleWZyYW1lc1J1bGUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAodHlwZW9mIChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0pID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLmdldChuYW1lKSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0aGlzLnVwZGF0ZU9uZSh0aGlzLmluZGV4W2luZGV4XSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlIHBsdWdpbnMsIHVwZGF0ZSBydWxlIHByb3BzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VXBkYXRlT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBsdWdpbnMgPSBfdGhpcyRvcHRpb25zMi5qc3MucGx1Z2lucyxcbiAgICAgICAgc2hlZXQgPSBfdGhpcyRvcHRpb25zMi5zaGVldDsgLy8gSXQgaXMgYSBydWxlcyBjb250YWluZXIgbGlrZSBmb3IgZS5nLiBDb25kaXRpb25hbFJ1bGUuXG5cbiAgICBpZiAocnVsZS5ydWxlcyBpbnN0YW5jZW9mIFJ1bGVMaXN0KSB7XG4gICAgICBydWxlLnJ1bGVzLnVwZGF0ZShkYXRhLCBvcHRpb25zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgIHBsdWdpbnMub25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpOyAvLyBXZSByZWx5IG9uIGEgbmV3IGBzdHlsZWAgcmVmIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2suXG5cbiAgICBpZiAob3B0aW9ucy5wcm9jZXNzICYmIHN0eWxlICYmIHN0eWxlICE9PSBydWxlLnN0eWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJ1biB0aGUgcGx1Z2lucyBpbiBjYXNlIG5ldyBgc3R5bGVgIHJlbGllcyBvbiBzeW50YXggcGx1Z2lucy5cbiAgICAgIHBsdWdpbnMub25Qcm9jZXNzU3R5bGUocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpOyAvLyBVcGRhdGUgYW5kIGFkZCBwcm9wcy5cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBydWxlLnN0eWxlKSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBydWxlLnN0eWxlW3Byb3BdO1xuICAgICAgICB2YXIgcHJldlZhbHVlID0gc3R5bGVbcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAobmV4dFZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICBydWxlLnByb3AocHJvcCwgbmV4dFZhbHVlLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbW92ZSBwcm9wcy5cblxuXG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBzdHlsZSkge1xuICAgICAgICB2YXIgX25leHRWYWx1ZSA9IHJ1bGUuc3R5bGVbX3Byb3BdO1xuICAgICAgICB2YXIgX3ByZXZWYWx1ZSA9IHN0eWxlW19wcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChfbmV4dFZhbHVlID09IG51bGwgJiYgX25leHRWYWx1ZSAhPT0gX3ByZXZWYWx1ZSkge1xuICAgICAgICAgIHJ1bGUucHJvcChfcHJvcCwgbnVsbCwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuaW5kZXhbaW5kZXhdO1xuICAgICAgdmFyIGNzcyA9IHJ1bGUudG9TdHJpbmcob3B0aW9ucyk7IC8vIE5vIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IHJ1bGUuXG5cbiAgICAgIGlmICghY3NzICYmICFsaW5rKSBjb250aW51ZTtcbiAgICAgIGlmIChzdHIpIHN0ciArPSBsaW5lYnJlYWs7XG4gICAgICBzdHIgKz0gY3NzO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIFJ1bGVMaXN0O1xufSgpO1xuXG52YXIgU3R5bGVTaGVldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBzaGVldDogdGhpcyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGNsYXNzZXM6IHRoaXMuY2xhc3NlcyxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXNcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLlJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IG9wdGlvbnMuUmVuZGVyZXIodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaCByZW5kZXJhYmxlIHRvIHRoZSByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuYXR0YWNoKCk7XG4gICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7IC8vIE9yZGVyIGlzIGltcG9ydGFudCwgYmVjYXVzZSB3ZSBjYW4ndCB1c2UgaW5zZXJ0UnVsZSBBUEkgaWYgc3R5bGUgZWxlbWVudCBpcyBub3QgYXR0YWNoZWQuXG5cbiAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHRoaXMuZGVwbG95KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSByZW5kZXJhYmxlIGZyb20gcmVuZGVyIHRyZWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICBpZiAoIXRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRldGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQWRkIGEgcnVsZSB0byB0aGUgY3VycmVudCBzdHlsZXNoZWV0LlxuICAgKiBXaWxsIGluc2VydCBhIHJ1bGUgYWxzbyBhZnRlciB0aGUgc3R5bGVzaGVldCBoYXMgYmVlbiByZW5kZXJlZCBmaXJzdCB0aW1lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTsgLy8gUGx1Z2lucyBjYW4gY3JlYXRlIHJ1bGVzLlxuICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSByaWdodCBvcmRlciwgd2UgbmVlZCB0byBxdWV1ZSBhbGwgYC5hZGRSdWxlYCBjYWxscyxcbiAgICAvLyB3aGljaCBoYXBwZW4gYWZ0ZXIgdGhlIGZpcnN0IGBydWxlcy5hZGQoKWAgY2FsbC5cblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFxdWV1ZSkgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHJldHVybiBydWxlOyAvLyBEb24ndCBpbnNlcnQgcnVsZSBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBzdHJpbmdpZmllZCB2ZXJzaW9uIHlldC5cbiAgICAgIC8vIEl0IHdpbGwgYmUgaW5zZXJ0ZWQgYWxsIHRvZ2V0aGVyIHdoZW4gLmF0dGFjaCBpcyBjYWxsZWQuXG5cbiAgICAgIGlmIChxdWV1ZSkgcXVldWUucHVzaChydWxlKTtlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZS5mb3JFYWNoKHRoaXMuaW5zZXJ0UnVsZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfSAvLyBXZSBjYW4ndCBhZGQgcnVsZXMgdG8gYSBkZXRhY2hlZCBzdHlsZSBub2RlLlxuICAgIC8vIFdlIHdpbGwgcmVkZXBsb3kgdGhlIHNoZWV0IG9uY2UgdXNlciB3aWxsIGF0dGFjaCBpdC5cblxuXG4gICAgdGhpcy5kZXBsb3llZCA9IGZhbHNlO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgcnVsZSBpbiB0aGUgY3VycmVudCBzdHlsZXNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKG5hbWVPclNlbGVjdG9yLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgdmFyIG9sZFJ1bGUgPSB0aGlzLnJ1bGVzLmdldChuYW1lT3JTZWxlY3Rvcik7XG4gICAgaWYgKCFvbGRSdWxlKSByZXR1cm4gdGhpcy5hZGRSdWxlKG5hbWVPclNlbGVjdG9yLCBkZWNsLCBvcHRpb25zKTtcbiAgICB2YXIgbmV3UnVsZSA9IHRoaXMucnVsZXMucmVwbGFjZShuYW1lT3JTZWxlY3RvciwgZGVjbCwgb3B0aW9ucyk7XG5cbiAgICBpZiAobmV3UnVsZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUobmV3UnVsZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICghdGhpcy5kZXBsb3llZCkgcmV0dXJuIG5ld1J1bGU7IC8vIERvbid0IHJlcGxhY2UgLyBkZWxldGUgcnVsZSBkaXJlY3RseSBpZiB0aGVyZSBpcyBubyBzdHJpbmdpZmllZCB2ZXJzaW9uIHlldC5cbiAgICAgIC8vIEl0IHdpbGwgYmUgaW5zZXJ0ZWQgYWxsIHRvZ2V0aGVyIHdoZW4gLmF0dGFjaCBpcyBjYWxsZWQuXG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgIGlmICghbmV3UnVsZSkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZShvbGRSdWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRSdWxlLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlcGxhY2VSdWxlKG9sZFJ1bGUucmVuZGVyYWJsZSwgbmV3UnVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1J1bGU7XG4gICAgfSAvLyBXZSBjYW4ndCByZXBsYWNlIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3UnVsZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZXMgPSBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIGFkZGVkLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUgb3Igc2VsZWN0b3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWVPclNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuZ2V0KG5hbWVPclNlbGVjdG9yKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZSBieSBuYW1lLlxuICAgKiBSZXR1cm5zIGB0cnVlYDogaWYgcnVsZSBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIERPTS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUobmFtZSkge1xuICAgIHZhciBydWxlID0gdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnID8gbmFtZSA6IHRoaXMucnVsZXMuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKCFydWxlIHx8IC8vIFN0eWxlIHNoZWV0IHdhcyBjcmVhdGVkIHdpdGhvdXQgbGluazogdHJ1ZSBhbmQgYXR0YWNoZWQsIGluIHRoaXMgY2FzZSB3ZVxuICAgIC8vIHdvbid0IGJlIGFibGUgdG8gcmVtb3ZlIHRoZSBDU1MgcnVsZSBmcm9tIHRoZSBET00uXG4gICAgdGhpcy5hdHRhY2hlZCAmJiAhcnVsZS5yZW5kZXJhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5yZW1vdmUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiBydWxlLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZGVsZXRlUnVsZShydWxlLnJlbmRlcmFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuaW5kZXhPZihydWxlKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95IHB1cmUgQ1NTIHN0cmluZyB0byBhIHJlbmRlcmFibGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXBsb3koKTtcbiAgICB0aGlzLmRlcGxveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBmdW5jdGlvbiB2YWx1ZXMgd2l0aCBhIG5ldyBkYXRhLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJHJ1bGVzO1xuXG4gICAgKF90aGlzJHJ1bGVzID0gdGhpcy5ydWxlcykudXBkYXRlLmFwcGx5KF90aGlzJHJ1bGVzLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBzaW5nbGUgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzLnVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBydWxlcyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG52YXIgUGx1Z2luc1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luc1JlZ2lzdHJ5KCkge1xuICAgIHRoaXMucGx1Z2lucyA9IHtcbiAgICAgIGludGVybmFsOiBbXSxcbiAgICAgIGV4dGVybmFsOiBbXVxuICAgIH07XG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsdWdpbnNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgKi9cbiAgX3Byb3RvLm9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgIH1cblxuICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgcnVsZS5zdHlsZSA9IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGVbaV0ocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTaGVldCA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKG5ld1BsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1ZXVlOiAnZXh0ZXJuYWwnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gdGhpcy5wbHVnaW5zW29wdGlvbnMucXVldWVdOyAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YobmV3UGx1Z2luKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gobmV3UGx1Z2luKTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCwgdGhpcy5wbHVnaW5zLmludGVybmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgcmVnaXN0cnlbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBob29rIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdpc3RyeTtcbiAgICB9LCB7XG4gICAgICBvbkNyZWF0ZVJ1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzUnVsZTogW10sXG4gICAgICBvblByb2Nlc3NTdHlsZTogW10sXG4gICAgICBvblByb2Nlc3NTaGVldDogW10sXG4gICAgICBvbkNoYW5nZVZhbHVlOiBbXSxcbiAgICAgIG9uVXBkYXRlOiBbXVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQbHVnaW5zUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogU2hlZXRzIHJlZ2lzdHJ5IHRvIGFjY2VzcyBhbGwgaW5zdGFuY2VzIGluIG9uZSBwbGFjZS5cbiAqL1xuXG52YXIgU2hlZXRzUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChzaGVldCkge1xuICAgIHZhciByZWdpc3RyeSA9IHRoaXMucmVnaXN0cnk7XG4gICAgdmFyIGluZGV4ID0gc2hlZXQub3B0aW9ucy5pbmRleDtcbiAgICBpZiAocmVnaXN0cnkuaW5kZXhPZihzaGVldCkgIT09IC0xKSByZXR1cm47XG5cbiAgICBpZiAocmVnaXN0cnkubGVuZ3RoID09PSAwIHx8IGluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgIHJlZ2lzdHJ5LnB1c2goc2hlZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHBvc2l0aW9uLlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVnaXN0cnlbaV0ub3B0aW9ucy5pbmRleCA+IGluZGV4KSB7XG4gICAgICAgIHJlZ2lzdHJ5LnNwbGljZShpLCAwLCBzaGVldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc2hlZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpO1xuICAgIHRoaXMucmVnaXN0cnkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhbGwgYXR0YWNoZWQgc2hlZXRzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIGF0dGFjaGVkID0gX3JlZi5hdHRhY2hlZCxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImF0dGFjaGVkXCJdKTtcblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIHZhciBjc3MgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5yZWdpc3RyeVtpXTtcblxuICAgICAgaWYgKGF0dGFjaGVkICE9IG51bGwgJiYgc2hlZXQuYXR0YWNoZWQgIT09IGF0dGFjaGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3NzKSBjc3MgKz0gbGluZWJyZWFrO1xuICAgICAgY3NzICs9IHNoZWV0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c1JlZ2lzdHJ5LCBbe1xuICAgIGtleTogXCJpbmRleFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoaWdoZXN0IGluZGV4IG51bWJlci5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCA/IDAgOiB0aGlzLnJlZ2lzdHJ5W3RoaXMucmVnaXN0cnkubGVuZ3RoIC0gMV0ub3B0aW9ucy5pbmRleDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzUmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogVGhpcyBpcyBhIGdsb2JhbCBzaGVldHMgcmVnaXN0cnkuIE9ubHkgRG9tUmVuZGVyZXIgd2lsbCBhZGQgc2hlZXRzIHRvIGl0LlxuICogT24gdGhlIHNlcnZlciBvbmUgc2hvdWxkIHVzZSBhbiBvd24gU2hlZXRzUmVnaXN0cnkgaW5zdGFuY2UgYW5kIGFkZCB0aGVcbiAqIHNoZWV0cyB0byBpdCwgYmVjYXVzZSB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdG8gY3JlYXRlIGEgbmV3IHJlZ2lzdHJ5IGZvclxuICogZWFjaCByZXF1ZXN0IGluIG9yZGVyIHRvIG5vdCBsZWFrIHNoZWV0cyBhY3Jvc3MgcmVxdWVzdHMuXG4gKi9cblxudmFyIHNoZWV0cyA9IG5ldyBTaGVldHNSZWdpc3RyeSgpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIE5vdyB0aGF0IGBnbG9iYWxUaGlzYCBpcyBhdmFpbGFibGUgb24gbW9zdCBwbGF0Zm9ybXNcbiAqIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9nbG9iYWxUaGlzI2Jyb3dzZXJfY29tcGF0aWJpbGl0eSlcbiAqIHdlIGNoZWNrIGZvciBgZ2xvYmFsVGhpc2AgZmlyc3QuIGBnbG9iYWxUaGlzYCBpcyBuZWNlc3NhcnkgZm9yIGpzc1xuICogdG8gcnVuIGluIEFnb3JpYydzIHNlY3VyZSB2ZXJzaW9uIG9mIEphdmFTY3JpcHQgKFNFUykuIFVuZGVyIFNFUyxcbiAqIGBnbG9iYWxUaGlzYCBleGlzdHMsIGJ1dCBgd2luZG93YCwgYHNlbGZgLCBhbmQgYEZ1bmN0aW9uKCdyZXR1cm5cbiAqIHRoaXMnKSgpYCBhcmUgYWxsIHVuZGVmaW5lZCBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxuICovXG52YXIgZ2xvYmFsVGhpcyQxID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgbnMgPSAnMmYxYWNjNmMzYTYwNmIwODJlNWVlZjVlNTQ0MTRmZmInO1xuaWYgKGdsb2JhbFRoaXMkMVtuc10gPT0gbnVsbCkgZ2xvYmFsVGhpcyQxW25zXSA9IDA7IC8vIEJ1bmRsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBKU1MgdmVyc2lvbnMgYXQgdGhlIHNhbWUgdGltZS4gSW4gb3JkZXIgdG8gaWRlbnRpZnlcbi8vIHRoZSBjdXJyZW50IHZlcnNpb24gd2l0aCBqdXN0IG9uZSBzaG9ydCBudW1iZXIgYW5kIHVzZSBpdCBmb3IgY2xhc3NlcyBnZW5lcmF0aW9uXG4vLyB3ZSB1c2UgYSBjb3VudGVyLiBBbHNvIGl0IGlzIG1vcmUgYWNjdXJhdGUsIGJlY2F1c2UgdXNlciBjYW4gbWFudWFsbHkgcmVldmFsdWF0ZVxuLy8gdGhlIG1vZHVsZS5cblxudmFyIG1vZHVsZUlkID0gZ2xvYmFsVGhpcyQxW25zXSsrO1xuXG52YXIgbWF4UnVsZXMgPSAxZTEwO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGVzIHVuaXF1ZSBjbGFzcyBuYW1lcyBiYXNlZCBvbiBjb3VudGVycy5cbiAqIFdoZW4gbmV3IGdlbmVyYXRvciBmdW5jdGlvbiBpcyBjcmVhdGVkLCBydWxlIGNvdW50ZXIgaXMgcmVzZXRlZC5cbiAqIFdlIG5lZWQgdG8gcmVzZXQgdGhlIHJ1bGUgY291bnRlciBmb3IgU1NSIGZvciBlYWNoIHJlcXVlc3QuXG4gKi9cblxudmFyIGNyZWF0ZUdlbmVyYXRlSWQgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0ZUlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBydWxlQ291bnRlciA9IDA7XG5cbiAgdmFyIGdlbmVyYXRlSWQgPSBmdW5jdGlvbiBnZW5lcmF0ZUlkKHJ1bGUsIHNoZWV0KSB7XG4gICAgcnVsZUNvdW50ZXIgKz0gMTtcblxuICAgIGlmIChydWxlQ291bnRlciA+IG1heFJ1bGVzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuIFJ1bGUgY291bnRlciBpcyBhdCBcIiArIHJ1bGVDb3VudGVyICsgXCIuXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBqc3NJZCA9ICcnO1xuICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgIGlmIChzaGVldCkge1xuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5qc3MuaWQgIT0gbnVsbCkge1xuICAgICAgICBqc3NJZCA9IFN0cmluZyhzaGVldC5vcHRpb25zLmpzcy5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWluaWZ5KSB7XG4gICAgICAvLyBVc2luZyBcImNcIiBiZWNhdXNlIGEgbnVtYmVyIGNhbid0IGJlIHRoZSBmaXJzdCBjaGFyIGluIGEgY2xhc3MgbmFtZS5cbiAgICAgIHJldHVybiBcIlwiICsgKHByZWZpeCB8fCAnYycpICsgbW9kdWxlSWQgKyBqc3NJZCArIHJ1bGVDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBydWxlLmtleSArIFwiLVwiICsgbW9kdWxlSWQgKyAoanNzSWQgPyBcIi1cIiArIGpzc0lkIDogJycpICsgXCItXCIgKyBydWxlQ291bnRlcjtcbiAgfTtcblxuICByZXR1cm4gZ2VuZXJhdGVJZDtcbn07XG5cbi8qKlxuICogQ2FjaGUgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IHRpbWUgYSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cblxudmFyIG1lbW9pemUgPSBmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciB2YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IGZuKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcbi8qKlxuICogR2V0IGEgc3R5bGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cblxuXG52YXIgZ2V0UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIGdldFByb3BlcnR5VmFsdWUoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICByZXR1cm4gY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcC5nZXQocHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgYSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuXG5cbnZhciBzZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5KGNzc1J1bGUsIHByb3AsIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgdmFyIGNzc1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNzc1ZhbHVlID0gdG9Dc3NWYWx1ZSh2YWx1ZSk7XG4gICAgfSAvLyBTdXBwb3J0IENTU1RPTS5cblxuXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuc2V0KHByb3AsIGNzc1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGV4T2ZJbXBvcnRhbnRGbGFnID0gY3NzVmFsdWUgPyBjc3NWYWx1ZS5pbmRleE9mKCchaW1wb3J0YW50JykgOiAtMTtcbiAgICAgIHZhciBjc3NWYWx1ZVdpdGhvdXRJbXBvcnRhbnRGbGFnID0gaW5kZXhPZkltcG9ydGFudEZsYWcgPiAtMSA/IGNzc1ZhbHVlLnN1YnN0cigwLCBpbmRleE9mSW1wb3J0YW50RmxhZyAtIDEpIDogY3NzVmFsdWU7XG4gICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlV2l0aG91dEltcG9ydGFudEZsYWcsIGluZGV4T2ZJbXBvcnRhbnRGbGFnID4gLTEgPyAnaW1wb3J0YW50JyA6ICcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmVtb3ZlIGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG52YXIgcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiByZW1vdmVQcm9wZXJ0eShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZGVsZXRlKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjc3NSdWxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBET01FeGNlcHRpb24gXFxcIlwiICsgZXJyLm1lc3NhZ2UgKyBcIlxcXCIgd2FzIHRocm93bi4gVHJpZWQgdG8gcmVtb3ZlIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIuXCIpIDogdm9pZCAwO1xuICB9XG59O1xuLyoqXG4gKiBTZXQgdGhlIHNlbGVjdG9yLlxuICovXG5cblxudmFyIHNldFNlbGVjdG9yID0gZnVuY3Rpb24gc2V0U2VsZWN0b3IoY3NzUnVsZSwgc2VsZWN0b3JUZXh0KSB7XG4gIGNzc1J1bGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0OyAvLyBSZXR1cm4gZmFsc2UgaWYgc2V0dGVyIHdhcyBub3Qgc3VjY2Vzc2Z1bC5cbiAgLy8gQ3VycmVudGx5IHdvcmtzIGluIGNocm9tZSBvbmx5LlxuXG4gIHJldHVybiBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9PT0gc2VsZWN0b3JUZXh0O1xufTtcbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhIG5vZGUgYmVmb3JlIHdoaWNoIHdlIGNhbiBpbnNlcnQgdGhlIHNoZWV0LlxuICovXG5cblxuZnVuY3Rpb24gZmluZFByZXZOb2RlKG9wdGlvbnMpIHtcbiAgdmFyIHJlZ2lzdHJ5ID0gc2hlZXRzLnJlZ2lzdHJ5O1xuXG4gIGlmIChyZWdpc3RyeS5sZW5ndGggPiAwKSB7XG4gICAgLy8gVHJ5IHRvIGluc2VydCBiZWZvcmUgdGhlIG5leHQgaGlnaGVyIHNoZWV0LlxuICAgIHZhciBzaGVldCA9IGZpbmRIaWdoZXJTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50XG4gICAgICB9O1xuICAgIH0gLy8gT3RoZXJ3aXNlIGluc2VydCBhZnRlciB0aGUgbGFzdCBhdHRhY2hlZC5cblxuXG4gICAgc2hlZXQgPSBmaW5kSGlnaGVzdFNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKTtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBzaGVldC5yZW5kZXJlci5lbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQubmV4dFNpYmxpbmdcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIFRyeSB0byBmaW5kIGEgY29tbWVudCBwbGFjZWhvbGRlciBpZiByZWdpc3RyeSBpcyBlbXB0eS5cblxuXG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY29tbWVudCA9IGZpbmRDb21tZW50Tm9kZShpbnNlcnRpb25Qb2ludCk7XG5cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyZW50OiBjb21tZW50LnBhcmVudE5vZGUsXG4gICAgICAgIG5vZGU6IGNvbW1lbnQubmV4dFNpYmxpbmdcbiAgICAgIH07XG4gICAgfSAvLyBJZiB1c2VyIHNwZWNpZmllcyBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIGl0IGNhbid0IGJlIGZvdW5kIGluIHRoZSBkb2N1bWVudCAtXG4gICAgLy8gYmFkIHNwZWNpZmljaXR5IGlzc3VlcyBtYXkgYXBwZWFyLlxuXG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEluc2VydGlvbiBwb2ludCBcXFwiXCIgKyBpbnNlcnRpb25Qb2ludCArIFwiXFxcIiBub3QgZm91bmQuXCIpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZShzdHlsZSwgb3B0aW9ucykge1xuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICB2YXIgbmV4dE5vZGUgPSBmaW5kUHJldk5vZGUob3B0aW9ucyk7XG5cbiAgaWYgKG5leHROb2RlICE9PSBmYWxzZSAmJiBuZXh0Tm9kZS5wYXJlbnQpIHtcbiAgICBuZXh0Tm9kZS5wYXJlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0Tm9kZS5ub2RlKTtcbiAgICByZXR1cm47XG4gIH0gLy8gV29ya3Mgd2l0aCBpZnJhbWVzIGFuZCBhbnkgbm9kZSB0eXBlcy5cblxuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQubm9kZVR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIGluc2VydGlvblBvaW50RWxlbWVudCA9IGluc2VydGlvblBvaW50O1xuICAgIHZhciBwYXJlbnROb2RlID0gaW5zZXJ0aW9uUG9pbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBpbnNlcnRpb25Qb2ludEVsZW1lbnQubmV4dFNpYmxpbmcpO2Vsc2UgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBpcyBub3QgaW4gdGhlIERPTS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuLyoqXG4gKiBSZWFkIGpzcyBub25jZSBzZXR0aW5nIGZyb20gdGhlIHBhZ2UgaWYgdGhlIHVzZXIgaGFzIHNldCBpdC5cbiAqL1xuXG5cbnZhciBnZXROb25jZSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbn0pO1xuXG52YXIgX2luc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKGNvbnRhaW5lciwgcnVsZSwgaW5kZXgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoJ2luc2VydFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgIH0gLy8gS2V5ZnJhbWVzIHJ1bGUuXG4gICAgZWxzZSBpZiAoJ2FwcGVuZFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kUnVsZShydWxlKTtcbiAgICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBcIiArIGVyci5tZXNzYWdlKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmNzc1J1bGVzW2luZGV4XTtcbn07XG5cbnZhciBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleCA9IGZ1bmN0aW9uIGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KGNvbnRhaW5lciwgaW5kZXgpIHtcbiAgdmFyIG1heEluZGV4ID0gY29udGFpbmVyLmNzc1J1bGVzLmxlbmd0aDsgLy8gSW4gY2FzZSBwcmV2aW91cyBpbnNlcnRpb24gZmFpbHMsIHBhc3NlZCBpbmRleCBtaWdodCBiZSB3cm9uZ1xuXG4gIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZXR1cm4gbWF4SW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG52YXIgY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsgLy8gV2l0aG91dCBpdCwgSUUgd2lsbCBoYXZlIGEgYnJva2VuIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBpZiB3ZVxuICAvLyBpbnNlcnQgcnVsZXMgYWZ0ZXIgd2UgaW5zZXJ0IHRoZSBzdHlsZSB0YWcuXG4gIC8vIEl0IHNlZW1zIHRvIGtpY2stb2ZmIHRoZSBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgYWxnb3JpdGhtLlxuXG4gIGVsLnRleHRDb250ZW50ID0gJ1xcbic7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBEb21SZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFdpbGwgYmUgZW1wdHkgaWYgbGluazogdHJ1ZSBvcHRpb24gaXMgbm90IHNldCwgYmVjYXVzZVxuICAvLyBpdCBpcyBvbmx5IGZvciB1c2UgdG9nZXRoZXIgd2l0aCBpbnNlcnRSdWxlIEFQSS5cbiAgZnVuY3Rpb24gRG9tUmVuZGVyZXIoc2hlZXQpIHtcbiAgICB0aGlzLmdldFByb3BlcnR5VmFsdWUgPSBnZXRQcm9wZXJ0eVZhbHVlO1xuICAgIHRoaXMuc2V0UHJvcGVydHkgPSBzZXRQcm9wZXJ0eTtcbiAgICB0aGlzLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XG4gICAgdGhpcy5zZXRTZWxlY3RvciA9IHNldFNlbGVjdG9yO1xuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuY3NzUnVsZXMgPSBbXTtcbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIHNoZWV0cy5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpOyAvLyBJbiB0aGUgbW9zdCBicm93c2VycywgcnVsZXMgaW5zZXJ0ZWQgdXNpbmcgaW5zZXJ0UnVsZSgpIEFQSSB3aWxsIGJlIGxvc3Qgd2hlbiBzdHlsZSBlbGVtZW50IGlzIHJlbW92ZWQuXG4gICAgLy8gVGhvdWdoIElFIHdpbGwga2VlcCB0aGVtIGFuZCB3ZSBuZWVkIGEgY29uc2lzdGVudCBiZWhhdmlvci5cblxuICAgIGlmICh0aGlzLnNoZWV0Lm9wdGlvbnMubGluaykge1xuICAgICAgdGhpcy5jc3NSdWxlcyA9IFtdO1xuICAgICAgdGhpcy5lbGVtZW50LnRleHRDb250ZW50ID0gJ1xcbic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgdmFyIF9pbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpOyAvLyBXZSBuZWVkIHRvIHJlbmRlciB0aGUgY29udGFpbmVyIHdpdGhvdXQgY2hpbGRyZW4gZmlyc3QuXG5cblxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBfaW5zZXJ0aW9uSW5kZXgpO1xuXG4gICAgICAgIGlmIChsYXRlc3ROYXRpdmVQYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIF9pbnNlcnRpb25JbmRleCwgbGF0ZXN0TmF0aXZlUGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IGdldFZhbGlkUnVsZUluc2VydGlvbkluZGV4KG5hdGl2ZVBhcmVudCwgaW5kZXgpO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluc2VydGlvbkluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgdGhpcy5yZWZDc3NSdWxlKHJ1bGUsIGluc2VydGlvbkluZGV4LCBuYXRpdmVSdWxlKTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfTtcblxuICBfcHJvdG8ucmVmQ3NzUnVsZSA9IGZ1bmN0aW9uIHJlZkNzc1J1bGUocnVsZSwgaW5kZXgsIGNzc1J1bGUpIHtcbiAgICBydWxlLnJlbmRlcmFibGUgPSBjc3NSdWxlOyAvLyBXZSBvbmx5IHdhbnQgdG8gcmVmZXJlbmNlIHRoZSB0b3AgbGV2ZWwgcnVsZXMsIGRlbGV0ZVJ1bGUgQVBJIGRvZXNuJ3Qgc3VwcG9ydCByZW1vdmluZyBuZXN0ZWQgcnVsZXNcbiAgICAvLyBsaWtlIHJ1bGVzIGluc2lkZSBtZWRpYSBxdWVyaWVzIG9yIGtleWZyYW1lc1xuXG4gICAgaWYgKHJ1bGUub3B0aW9ucy5wYXJlbnQgaW5zdGFuY2VvZiBTdHlsZVNoZWV0KSB7XG4gICAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMCwgY3NzUnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVSdWxlID0gZnVuY3Rpb24gZGVsZXRlUnVsZShjc3NSdWxlKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5lbGVtZW50LnNoZWV0O1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHJldHVybiB0aGlzLmNzc1J1bGVzLmluZGV4T2YoY3NzUnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoY3NzUnVsZSwgcnVsZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihjc3NSdWxlKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5lbGVtZW50LnNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjEwLjBcIjtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgUGx1Z2luc1JlZ2lzdHJ5KCk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaWQ6IHtcbiAgICAgICAgbWluaWZ5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUdlbmVyYXRlSWQ6IGNyZWF0ZUdlbmVyYXRlSWQsXG4gICAgICBSZW5kZXJlcjogaXNJbkJyb3dzZXIgPyBEb21SZW5kZXJlciA6IG51bGwsXG4gICAgICBwbHVnaW5zOiBbXVxuICAgIH07XG4gICAgdGhpcy5nZW5lcmF0ZUlkID0gY3JlYXRlR2VuZXJhdGVJZCh7XG4gICAgICBtaW5pZnk6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucGx1Z2lucy51c2UocGx1Z2luc1tpXSwge1xuICAgICAgICBxdWV1ZTogJ2ludGVybmFsJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZXMgdmFyaW91cyBvcHRpb25zLCBhcHBsaWVzIHBsdWdpbnMuXG4gICAqIFNob3VsZCBub3QgYmUgdXNlZCB0d2ljZSBvbiB0aGUgc2FtZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGVyZSBpcyBubyBwbHVnaW5zXG4gICAqIGRlZHVwbGljYXRpb24gbG9naWMuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEpzcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldHVwID0gZnVuY3Rpb24gc2V0dXAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCA9IG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlkID0gX2V4dGVuZHMoe30sIHRoaXMub3B0aW9ucy5pZCwgb3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCB8fCBvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSWQgPSB0aGlzLm9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCh0aGlzLm9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluc2VydGlvblBvaW50ICE9IG51bGwpIHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG5cbiAgICBpZiAoJ1JlbmRlcmVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuUmVuZGVyZXIgPSBvcHRpb25zLlJlbmRlcmVyO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcblxuXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykgdGhpcy51c2UuYXBwbHkodGhpcywgb3B0aW9ucy5wbHVnaW5zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgU3R5bGUgU2hlZXQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICBpbmRleCA9IF9vcHRpb25zLmluZGV4O1xuXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gc2hlZXRzLmluZGV4ID09PSAwID8gMCA6IHNoZWV0cy5pbmRleCArIDE7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gbmV3IFN0eWxlU2hlZXQoc3R5bGVzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAganNzOiB0aGlzLFxuICAgICAgZ2VuZXJhdGVJZDogb3B0aW9ucy5nZW5lcmF0ZUlkIHx8IHRoaXMuZ2VuZXJhdGVJZCxcbiAgICAgIGluc2VydGlvblBvaW50OiB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSkpO1xuICAgIHRoaXMucGx1Z2lucy5vblByb2Nlc3NTaGVldChzaGVldCk7XG4gICAgcmV0dXJuIHNoZWV0O1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2ggdGhlIFN0eWxlIFNoZWV0IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZVN0eWxlU2hlZXQgPSBmdW5jdGlvbiByZW1vdmVTdHlsZVNoZWV0KHNoZWV0KSB7XG4gICAgc2hlZXQuZGV0YWNoKCk7XG4gICAgc2hlZXRzLnJlbW92ZShzaGVldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJ1bGUgd2l0aG91dCBhIFN0eWxlIFNoZWV0LlxuICAgKiBbRGVwcmVjYXRlZF0gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBjcmVhdGVSdWxlJDEobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkge1xuICAgICAgc3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIHJ1bGUgd2l0aG91dCBuYW1lIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJ1bGUodW5kZWZpbmVkLCBuYW1lLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVPcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBSZW5kZXJlcjogdGhpcy5vcHRpb25zLlJlbmRlcmVyXG4gICAgfSk7XG5cbiAgICBpZiAoIXJ1bGVPcHRpb25zLmdlbmVyYXRlSWQpIHJ1bGVPcHRpb25zLmdlbmVyYXRlSWQgPSB0aGlzLmdlbmVyYXRlSWQ7XG4gICAgaWYgKCFydWxlT3B0aW9ucy5jbGFzc2VzKSBydWxlT3B0aW9ucy5jbGFzc2VzID0ge307XG4gICAgaWYgKCFydWxlT3B0aW9ucy5rZXlmcmFtZXMpIHJ1bGVPcHRpb25zLmtleWZyYW1lcyA9IHt9O1xuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBydWxlT3B0aW9ucyk7XG5cbiAgICBpZiAocnVsZSkgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHBsdWdpbi4gUGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aXRoIGEgcnVsZSBpbnN0YW5jZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIF90aGlzLnBsdWdpbnMudXNlKHBsdWdpbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIEpzcztcbn0oKTtcblxudmFyIGNyZWF0ZUpzcyA9IGZ1bmN0aW9uIGNyZWF0ZUpzcyhvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTaGVldHNNYW5hZ2VyIGlzIGxpa2UgYSBXZWFrTWFwIHdoaWNoIGlzIGRlc2lnbmVkIHRvIGNvdW50IFN0eWxlU2hlZXRcbiAqIGluc3RhbmNlcyBhbmQgYXR0YWNoL2RldGFjaCBhdXRvbWF0aWNhbGx5LlxuICogVXNlZCBpbiByZWFjdC1qc3MuXG4gKi9cblxudmFyIFNoZWV0c01hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNNYW5hZ2VyKCkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNoZWV0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzTWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkuc2hlZXQ7XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChrZXksIHNoZWV0KSB7XG4gICAgaWYgKHRoaXMuc2hlZXRzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLnNoZWV0cy5zZXQoa2V5LCB7XG4gICAgICBzaGVldDogc2hlZXQsXG4gICAgICByZWZzOiAwXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLm1hbmFnZSA9IGZ1bmN0aW9uIG1hbmFnZShrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnNoZWV0cy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgaWYgKGVudHJ5LnJlZnMgPT09IDApIHtcbiAgICAgICAgZW50cnkuc2hlZXQuYXR0YWNoKCk7XG4gICAgICB9XG5cbiAgICAgIGVudHJ5LnJlZnMrKztcbiAgICAgIHJldHVybiBlbnRyeS5zaGVldDtcbiAgICB9XG5cbiAgICB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFNoZWV0c01hbmFnZXI6IGNhbid0IGZpbmQgc2hlZXQgdG8gbWFuYWdlXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnVubWFuYWdlID0gZnVuY3Rpb24gdW5tYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID4gMCkge1xuICAgICAgICBlbnRyeS5yZWZzLS07XG4gICAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSBlbnRyeS5zaGVldC5kZXRhY2goKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIHVubWFuYWdlXCIpO1xuICAgIH1cbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzTWFuYWdlciwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNNYW5hZ2VyO1xufSgpO1xuXG4vKipcbiogRXhwb3J0IGEgY29uc3RhbnQgaW5kaWNhdGluZyBpZiB0aGlzIGJyb3dzZXIgaGFzIENTU1RPTSBzdXBwb3J0LlxuKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE4LzAzL2Nzc29tXG4qL1xudmFyIGhhc0NTU1RPTVN1cHBvcnQgPSB0eXBlb2YgQ1NTID09PSAnb2JqZWN0JyAmJiBDU1MgIT0gbnVsbCAmJiAnbnVtYmVyJyBpbiBDU1M7XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzdHlsZXMgb2JqZWN0IHdpdGggb25seSBwcm9wcyB0aGF0IGNvbnRhaW4gZnVuY3Rpb24gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU3R5bGVzKHN0eWxlcykge1xuICB2YXIgdG8gPSBudWxsO1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIXRvKSB0byA9IHt9O1xuICAgICAgdG9ba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkID0gZ2V0RHluYW1pY1N0eWxlcyh2YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYWN0ZWQpIHtcbiAgICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgICAgdG9ba2V5XSA9IGV4dHJhY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogQSBiZXR0ZXIgYWJzdHJhY3Rpb24gb3ZlciBDU1MuXG4gKlxuICogQGNvcHlyaWdodCBPbGVnIElzb25lbiAoU2xvYm9kc2tvaSkgLyBJc29uZW4gMjAxNC1wcmVzZW50XG4gKiBAd2Vic2l0ZSBodHRwczovL2dpdGh1Yi5jb20vY3NzaW5qcy9qc3NcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgaW5kZXggPSBjcmVhdGVKc3MoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG5leHBvcnQgeyBSdWxlTGlzdCwgU2hlZXRzTWFuYWdlciwgU2hlZXRzUmVnaXN0cnksIGNyZWF0ZUpzcyBhcyBjcmVhdGUsIGNyZWF0ZUdlbmVyYXRlSWQsIGNyZWF0ZVJ1bGUsIGdldER5bmFtaWNTdHlsZXMsIGhhc0NTU1RPTVN1cHBvcnQsIHNoZWV0cywgdG9Dc3NWYWx1ZSB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiaXNJbkJyb3dzZXIiLCJ3YXJuaW5nIiwiX2NyZWF0ZUNsYXNzIiwiX2luaGVyaXRzTG9vc2UiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJwbGFpbk9iamVjdENvbnN0cnVyY3RvciIsImNvbnN0cnVjdG9yIiwiY2xvbmVTdHlsZSIsInN0eWxlIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwibmV3U3R5bGUiLCJuYW1lIiwiY3JlYXRlUnVsZSIsImRlY2wiLCJvcHRpb25zIiwianNzIiwiZGVjbENvcHkiLCJydWxlIiwicGx1Z2lucyIsIm9uQ3JlYXRlUnVsZSIsImpvaW4iLCJ2YWx1ZSIsImJ5IiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInRvQ3NzVmFsdWUiLCJjc3NWYWx1ZSIsImdldFdoaXRlc3BhY2VTeW1ib2xzIiwiZm9ybWF0IiwibGluZWJyZWFrIiwic3BhY2UiLCJpbmRlbnRTdHIiLCJzdHIiLCJpbmRlbnQiLCJpbmRleCIsInRvQ3NzIiwic2VsZWN0b3IiLCJfb3B0aW9ucyIsIl9vcHRpb25zJGluZGVudCIsImZhbGxiYWNrcyIsIkluZmluaXR5IiwiX2dldFdoaXRlc3BhY2VTeW1ib2xzIiwiZmFsbGJhY2siLCJwcm9wIiwiX3Byb3AiLCJfdmFsdWUiLCJfcHJvcDIiLCJfdmFsdWUyIiwiYWxsb3dFbXB0eSIsImVzY2FwZVJlZ2V4IiwibmF0aXZlRXNjYXBlIiwiQ1NTIiwiZXNjYXBlIiwicmVwbGFjZSIsIkJhc2VTdHlsZVJ1bGUiLCJrZXkiLCJ0eXBlIiwiaXNQcm9jZXNzZWQiLCJzaGVldCIsIlJlbmRlcmVyIiwicmVuZGVyZXIiLCJfcHJvdG8iLCJwcm90b3R5cGUiLCJ1bmRlZmluZWQiLCJmb3JjZSIsIm5ld1ZhbHVlIiwicHJvY2VzcyIsIm9uQ2hhbmdlVmFsdWUiLCJpc0VtcHR5IiwiaXNEZWZpbmVkIiwicmVtb3ZlIiwicmVuZGVyYWJsZSIsInJlbW92ZVByb3BlcnR5Iiwic2V0UHJvcGVydHkiLCJhdHRhY2hlZCIsIlN0eWxlUnVsZSIsIl9CYXNlU3R5bGVSdWxlIiwiX3RoaXMiLCJjYWxsIiwic2NvcGVkIiwiZ2VuZXJhdGVJZCIsInNlbGVjdG9yVGV4dCIsImlkIiwiX3Byb3RvMiIsImFwcGx5VG8iLCJqc29uIiwidG9KU09OIiwidG9TdHJpbmciLCJsaW5rIiwib3B0cyIsInNldCIsImhhc0NoYW5nZWQiLCJzZXRTZWxlY3RvciIsInJlcGxhY2VSdWxlIiwiZ2V0IiwicGx1Z2luU3R5bGVSdWxlIiwicGFyZW50IiwiZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyIsImNoaWxkcmVuIiwiYXRSZWdFeHAiLCJDb25kaXRpb25hbFJ1bGUiLCJzdHlsZXMiLCJhdE1hdGNoIiwibWF0Y2giLCJhdCIsInF1ZXJ5IiwicnVsZXMiLCJSdWxlTGlzdCIsImFkZCIsImdldFJ1bGUiLCJpbmRleE9mIiwiYWRkUnVsZSIsIm9uUHJvY2Vzc1J1bGUiLCJuZXdSdWxlIiwia2V5UmVnRXhwIiwicGx1Z2luQ29uZGl0aW9uYWxSdWxlIiwidGVzdCIsImRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMSIsIm5hbWVSZWdFeHAiLCJLZXlmcmFtZXNSdWxlIiwiZnJhbWVzIiwibmFtZU1hdGNoIiwia2V5UmVnRXhwJDEiLCJyZWZSZWdFeHAiLCJmaW5kUmVmZXJlbmNlZEtleWZyYW1lIiwidmFsIiwia2V5ZnJhbWVzIiwicmVwbGFjZVJlZiIsInJlZktleWZyYW1lIiwicGx1Z2luS2V5ZnJhbWVzUnVsZSIsIm9uUHJvY2Vzc1N0eWxlIiwiS2V5ZnJhbWVSdWxlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwbHVnaW5LZXlmcmFtZVJ1bGUiLCJGb250RmFjZVJ1bGUiLCJrZXlSZWdFeHAkMiIsInBsdWdpbkZvbnRGYWNlUnVsZSIsIlZpZXdwb3J0UnVsZSIsInBsdWdpblZpZXdwb3J0UnVsZSIsIlNpbXBsZVJ1bGUiLCJrZXlzTWFwIiwicGx1Z2luU2ltcGxlUnVsZSIsImRlZmF1bHRVcGRhdGVPcHRpb25zIiwiZm9yY2VVcGRhdGVPcHRpb25zIiwicmF3IiwiY291bnRlciIsImNsYXNzZXMiLCJydWxlT3B0aW9ucyIsIl90aGlzJG9wdGlvbnMiLCJyZWdpc3RlciIsInNwbGljZSIsIm9sZFJ1bGUiLCJvbGRJbmRleCIsIm5hbWVPclNlbGVjdG9yIiwidW5yZWdpc3RlciIsInNsaWNlIiwiZm9yRWFjaCIsInVwZGF0ZSIsImRhdGEiLCJ1cGRhdGVPbmUiLCJfdGhpcyRvcHRpb25zMiIsIm9uVXBkYXRlIiwibmV4dFZhbHVlIiwicHJldlZhbHVlIiwiX25leHRWYWx1ZSIsIl9wcmV2VmFsdWUiLCJjc3MiLCJTdHlsZVNoZWV0IiwiZGVwbG95ZWQiLCJhdHRhY2giLCJkZXBsb3kiLCJkZXRhY2giLCJxdWV1ZSIsInB1c2giLCJpbnNlcnRSdWxlIiwiZGVsZXRlUnVsZSIsImFkZFJ1bGVzIiwiYWRkZWQiLCJfdGhpcyRydWxlcyIsIlBsdWdpbnNSZWdpc3RyeSIsImludGVybmFsIiwiZXh0ZXJuYWwiLCJyZWdpc3RyeSIsIm9uUHJvY2Vzc1NoZWV0IiwicHJvY2Vzc2VkVmFsdWUiLCJ1c2UiLCJuZXdQbHVnaW4iLCJjb25jYXQiLCJyZWR1Y2UiLCJwbHVnaW4iLCJTaGVldHNSZWdpc3RyeSIsInJlc2V0IiwiX3RlbXAiLCJfcmVmIiwic2hlZXRzIiwiZ2xvYmFsVGhpcyQxIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsIk1hdGgiLCJzZWxmIiwiRnVuY3Rpb24iLCJucyIsIm1vZHVsZUlkIiwibWF4UnVsZXMiLCJjcmVhdGVHZW5lcmF0ZUlkIiwicnVsZUNvdW50ZXIiLCJqc3NJZCIsInByZWZpeCIsImNsYXNzTmFtZVByZWZpeCIsIlN0cmluZyIsIm1pbmlmeSIsIm1lbW9pemUiLCJmbiIsImdldFByb3BlcnR5VmFsdWUiLCJjc3NSdWxlIiwiYXR0cmlidXRlU3R5bGVNYXAiLCJlcnIiLCJpbmRleE9mSW1wb3J0YW50RmxhZyIsImNzc1ZhbHVlV2l0aG91dEltcG9ydGFudEZsYWciLCJzdWJzdHIiLCJkZWxldGUiLCJtZXNzYWdlIiwiZ2V0SGVhZCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImZpbmRIaWdoZXJTaGVldCIsImluc2VydGlvblBvaW50IiwiZmluZEhpZ2hlc3RTaGVldCIsImZpbmRDb21tZW50Tm9kZSIsInRleHQiLCJoZWFkIiwiY2hpbGROb2RlcyIsIm5vZGUiLCJub2RlVHlwZSIsIm5vZGVWYWx1ZSIsInRyaW0iLCJmaW5kUHJldk5vZGUiLCJlbGVtZW50IiwicGFyZW50Tm9kZSIsIm5leHRTaWJsaW5nIiwiY29tbWVudCIsImluc2VydFN0eWxlIiwibmV4dE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnRpb25Qb2ludEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImdldE5vbmNlIiwiZ2V0QXR0cmlidXRlIiwiX2luc2VydFJ1bGUiLCJjb250YWluZXIiLCJhcHBlbmRSdWxlIiwiY3NzUnVsZXMiLCJnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleCIsIm1heEluZGV4IiwiY3JlYXRlU3R5bGUiLCJlbCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0Q29udGVudCIsIkRvbVJlbmRlcmVyIiwiaGFzSW5zZXJ0ZWRSdWxlcyIsIm1lZGlhIiwibWV0YSIsInNldEF0dHJpYnV0ZSIsIm5vbmNlIiwiQm9vbGVhbiIsInJlbW92ZUNoaWxkIiwiaW5zZXJ0UnVsZXMiLCJuYXRpdmVQYXJlbnQiLCJsYXRlc3ROYXRpdmVQYXJlbnQiLCJfaW5zZXJ0aW9uSW5kZXgiLCJyZWZDc3NSdWxlIiwicnVsZVN0ciIsImluc2VydGlvbkluZGV4IiwibmF0aXZlUnVsZSIsImdldFJ1bGVzIiwiaW5zdGFuY2VDb3VudGVyIiwiSnNzIiwidmVyc2lvbiIsInNldHVwIiwiY3JlYXRlU3R5bGVTaGVldCIsInJlbW92ZVN0eWxlU2hlZXQiLCJjcmVhdGVSdWxlJDEiLCJfbGVuIiwiX2tleSIsImNyZWF0ZUpzcyIsIlNoZWV0c01hbmFnZXIiLCJXZWFrTWFwIiwiZW50cnkiLCJoYXMiLCJyZWZzIiwibWFuYWdlIiwidW5tYW5hZ2UiLCJoYXNDU1NUT01TdXBwb3J0IiwiZ2V0RHluYW1pY1N0eWxlcyIsInRvIiwiZXh0cmFjdGVkIiwiY3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jss/dist/jss.esm.js\n");

/***/ })

};
;